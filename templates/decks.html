{% extends 'base.html' %}

{% block title %}Deck Builder - PvPocket{% endblock %}

{% block extra_css %}
{# Link for Bootstrap Icons, specific to this page #}
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
{# STYLE #}
<style>
    /* Utility classes for common patterns */
    .smooth-transition { transition: all 0.2s ease; }
    .transform-transition { transition: transform 0.2s ease; }
    .hover-scale:hover { transform: scale(1.05); }
    .card-radius { border-radius: 3.5%; }
    .btn-radius { border-radius: 8px; }
    .circle-radius { border-radius: 50%; }
    
    .navbar {
        margin-bottom: 0px;
    }
    .navbar-brand {
        font-weight: bold;
        font-size: 1.5rem;
    }
    .container {
        padding-left: 10px;
        padding-right: 5px;
        max-width: 98%;
    }
    #main-navbar-container .navbar-collapse {
        justify-content: center !important;
        flex-grow: 0;
    }
    #main-navbar-container .navbar-nav.me-auto {
        margin-right: 0 !important;
    }
    #main-navbar-container .navbar-nav.ms-auto {
        margin-left: 0 !important;
    }
    #main-navbar-container .navbar-nav:not(:last-child) {
        margin-right: 1rem;
    }
    .deck-builder-main-row {
        display: flex;
        flex-wrap: wrap;
    }
    .add-cards-wrapper .card,
    .current-deck-wrapper .card {
        display: flex;
        flex-direction: column;
        height: 100%;
        min-height: 65vh;
    }
    .col-md-8.mb-4 .card-body {
        flex-grow: 1;
        overflow: hidden;
        padding: 0;
        position: relative;
    }
    .col-md-8.mb-4 .card-header {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        justify-content: flex-start;
        flex-wrap: nowrap;
        padding: 10px !important;
    }
    .col-md-8.mb-4 .card-header .input-group {
        flex-grow: 1;
        flex-shrink: 1;
        min-width: 150px;
        margin-bottom: 0;
    }
    .col-md-8.mb-4 .card-header .dropdown {
        flex-shrink: 0;
        width: 85px;
        min-width: 85px;
        margin-bottom: 0;
    }
    .col-md-8.mb-4 .card-header .dropdown button {
        width: 100%;
        min-width: auto;
        font-size: 14px;
        padding: 10px 15px;
        text-align: left;
    }
    .col-md-8.mb-4 .card-header .dropdown .dropdown-toggle::after {
        display: none;
    }
    .filter-bar {
        padding: 15px;
        margin-bottom: 20px;
        background-color: var(--settings-bg);
        border: 1px solid var(--border-color);
    }
    .filter-bar .row {
        display: flex;
        flex-wrap: wrap;
        margin-right: -5px;
        margin-left: -5px;
        align-items: flex-start;
    }
    .filter-bar .col-md-8,
    .filter-bar .col-md-4 {
        padding: 0 10px;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
    }
    .filter-bar .col-md-4 {
        padding-top: 0;
    }
    .filter-bar .col-md-8 .row {
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        width: 100%;
    }
    .filter-bar .col-md-3 {
        padding: 0 5px;
        flex: 1;
        min-width: 0;
    }
    .filter-label,
    .filter-label-top,
    .filter-label-top-color {
        font-size: 0.8rem;
        color: var(--text-color);
        opacity: 0.7;
        font-weight: 600;
        text-transform: uppercase;
        margin-bottom: 4px;
        display: block;
        line-height: 1;
    }
    .filter-container {
        display: flex;
        flex-direction: column;
        min-height: 74px;
        justify-content: flex-start;
    }
    .filter-bar .dropdown button {
        width: 100%;
        min-width: 80px;
        min-height: 44px;
        font-size: 14px;
        padding: 10px 15px;
        border: 1px solid var(--border-color);
        background-color: var(--input-bg);
        color: var(--input-text);
        line-height: 1.3;
        box-sizing: border-box;
        display: flex;
        align-items: center;
        justify-content: space-between;
        text-align: left;
    }
    .filter-bar .dropdown button .btn-text {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        flex: 1;
        min-width: 0;
    }
    .filter-bar .dropdown-toggle::after {
        content: "";
        border-top: 4px solid;
        border-right: 4px solid transparent;
        border-left: 4px solid transparent;
        margin-left: 8px;
        flex-shrink: 0;
        width: 0;
        height: 0;
        vertical-align: middle;
    }
    .filter-bar .dropdown-menu {
        width: 100%;
        max-height: 500px;
        overflow-y: auto;
    }
    .filter-bar .dropdown-menu .dropdown-item {
        border-bottom: 1px solid #e9ecef;
        white-space: normal;
        word-wrap: break-word;
    }

    /* Force dropdown menus to stay light even in dark mode */
    .dropdown-menu {
        background-color: #ffffff !important;
        border: 1px solid #dee2e6 !important;
        color: #212529 !important;
    }

    .dropdown-menu .dropdown-item {
        color: #212529 !important;
        background-color: transparent !important;
    }

    .dropdown-menu .dropdown-item:hover,
    .dropdown-menu .dropdown-item:focus {
        background-color: #f8f9fa !important;
        color: #1e2125 !important;
    }

    .dropdown-menu .dropdown-item.active {
        background-color: #0d6efd !important;
        color: #ffffff !important;
    }

    /* Ensure this applies even in dark mode */
    [data-theme="dark"] .dropdown-menu {
        background-color: #ffffff !important;
        border: 1px solid #dee2e6 !important;
        color: #212529 !important;
    }

    [data-theme="dark"] .dropdown-menu .dropdown-item {
        color: #212529 !important;
        background-color: transparent !important;
    }

    [data-theme="dark"] .dropdown-menu .dropdown-item:hover,
    [data-theme="dark"] .dropdown-menu .dropdown-item:focus {
        background-color: #f8f9fa !important;
        color: #1e2125 !important;
    }

    [data-theme="dark"] .dropdown-menu .dropdown-item.active {
        background-color: #0d6efd !important;
        color: #ffffff !important;
    }
    .filter-bar .energy-icons {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        justify-content: flex-start;
        margin-top: 5px;
        width: 100%;
        overflow: visible;
    }
    .energy-icon-wrapper {
        position: relative;
        cursor: pointer;
        width: 29px;
        height: 29px;
        border-radius: 50%;
        overflow: visible;
        transition: all 0.2s ease;
        flex-shrink: 0;
    }
    .energy-icon-wrapper:not(.active) {
        opacity: 0.5;
        filter: saturate(0.8);
    }
    .energy-icon-wrapper:hover {
        opacity: 0.9;
        filter: saturate(0.9);
    }
    .energy-icon-wrapper.active {
        opacity: 1;
        filter: saturate(1.1);
        transform: scale(1.2);
        box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        z-index: 2;
    }
    .energy-icon-wrapper.active.typed {
        cursor: not-allowed;
    }
    .energy-icon {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
    }
    .energy-icon-wrapper.deck-energy {
        width: 25px;
        height: 25px;
        margin: 0 2px;
    }
    .deck-energy {
        cursor: pointer;
        transition: all 0.2s ease;
        opacity: 0.5;
        width: 27px;
        height: 27px;
        margin: 0;
    }
    .deck-energy.active,
    .energy-icon-wrapper.deck-energy.active {
        opacity: 1 !important;
        transform: scale(1.15) !important;
        box-shadow: 0 2px 6px rgba(0,0,0,0.3) !important;
    }
    #card-collection {
        overflow-y: scroll;
        padding: 15px;
        padding-bottom: 10px;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
    }
    #card-collection::-webkit-scrollbar {
        width: 8px;
    }
    #card-collection::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 10px;
    }
    #card-collection::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 10px;
    }
    #card-collection::-webkit-scrollbar-thumb:hover {
        background: #555;
    }
    [data-theme="dark"] #card-collection::-webkit-scrollbar-track {
        background: var(--bg-color);
    }
    [data-theme="dark"] #card-collection::-webkit-scrollbar-thumb {
        background: var(--border-color);
    }
    .card-item {
        position: relative;
        margin-bottom: 200px;
        will-change: transform;
    }
    .card-item img {
        width: 100%;
        border-radius: 3.5%;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        transition: all 0.2s ease;
        cursor: pointer;
    }
    .card-item:hover {
        transform: scale(1.05);
        transition: transform 0.2s ease;
    }
    .card-item:hover img {
        box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        transition: all 0.2s ease;
    }
    .card-item .badge,
    .card-item .btn-remove-small {
        transition: transform 0.2s ease;
        z-index: 10;
    }
    .card-item:hover .badge {
        /* No transform - keep badge anchored to card like remove button */
        transition: all 0.2s ease;
    }
    .card-item .badge {
        position: absolute;
        top: 5px;
        left: 5px;
        width: 28px;
        height: 28px;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
        background-color: rgba(0, 13, 130, 0.826) !important;
        color: white;
        font-weight: 600;
        border: none;
        font-size: 12px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    .clickable-card {
        cursor: pointer;
        position: relative;
        transition: transform 0.2s ease;
    }
    .clickable-card::before {
        content: '+';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 36px;
        height: 36px;
        background-color: rgba(40, 40, 40, 0.8);
        color: #2ecc71;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        z-index: 10;
        padding-bottom: 4px;
        font-weight: bold;
        font-size: 24px;
        pointer-events: none;
        transition: all 0.2s ease;
    }
    .clickable-card:hover::before {
        opacity: 0.9;
        transform: translate(-50%, -50%) scale(1.05);
    }
    [data-theme="dark"] .clickable-card::before {
        background-color: rgba(60, 60, 60, 0.8);
        color: #2ecc71;
    }
    .col-6.col-sm-4.col-md-3.col-lg-2.mb-3 {
        margin-bottom: 7px !important;
    }
    #search-input.form-control {
        background-color: var(--input-bg);
        color: var(--input-text);
        border-color: var(--border-color);
    }
    #search-input::placeholder,
    #deck-name::placeholder {
        color: var(--text-color);
        opacity: 0.6;
    }
    [data-theme="dark"] #search-input::placeholder,
    [data-theme="dark"] #deck-name::placeholder {
        color: var(--text-color);
        opacity: 0.5;
    }
    .input-group > span.input-group-text:first-child {
        background-color: var(--input-bg);
        border-color: var(--border-color);
        color: var(--text-color);
        opacity: 0.7;
    }
    #card-count-search {
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: var(--input-bg);
        color: var(--input-text);
        border: 1px solid var(--border-color);
        border-left: none;
        padding: 0.6rem 0.75rem;
        padding-top: calc(0.6rem + 2.9px);
        font-size: 0.875rem;
        border-top-right-radius: var(--bs-border-radius);
        border-bottom-right-radius: var(--bs-border-radius);
        border-top-left-radius: 0;
        border-bottom-left-radius: 0;
    }
    [data-theme="dark"] #card-count-search {
        color: #FFFFFF !important;
    }
    :root:not([data-theme="dark"]) #card-count-search,
    body:not([data-theme="dark"]) #card-count-search {
        color: #343a40;
    }
    .sort-arrow i {
        margin-left: 0.25rem;
        font-size: 0.8em;
    }
    #current-deck {
        height: 100%;
        overflow-y: auto;
        overflow-x: hidden;
        padding: 5px;
        width: 100%;
    }
    .current-deck-container .card {
        padding-right: 0;
        overflow: hidden;
    }
    .current-deck-container .card-body {
        padding: 10px;
    }
    .card-header {
        padding: 10px !important;
        padding-bottom: 7px !important;
    }
    .current-deck-container .card-header {
        background-color: var(--settings-bg);
        border-bottom: 1px solid var(--border-color);
        padding: 15px;
        padding-bottom: 0px !important;
    }
    [data-theme="dark"] .current-deck-container .card-header {
        background-color: #2c3136;
        border-bottom-color: var(--border-color);
    }
    .deck-header-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }
    .input-group {
        display: flex;
        align-items: stretch;
        width: 100%;
        margin-bottom: 5px;
    }
    #deck-name {
        height: 45px;
        border-radius: 8px 0 0 8px;
        border: 1px solid white;
        padding: 0 12px;
        flex-grow: 1;
    }
    #save-deck-btn, #clear-deck-btn {
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0 16px;
        font-weight: 500;
        border-radius: 0%;
    }
    .deck-counter {
        background-color: rgba(52, 58, 64, 0.55) !important;
        color: white;
        font-weight: 600;
        border-radius: 0 8px 8px 0;
        min-width: 70px;
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2), inset 0 0 0 1px white;
        border-left: none;
    }
    .deck-counter.full {
        background-color: rgba(52, 58, 64) !important;
    }
    .energy-section {
        margin-top: 12px;
    }
    .energy-label {
        margin-right: 8px;
        margin-left: 6px;
        margin-top: 4px;
        margin-bottom: 8px;
        color: #444;
        display: block;
        font-size: 16px;
    }
    [data-theme="dark"] .energy-label {
        color: var(--text-color);
        opacity: 0.9;
    }
    .energy-selection-bar {
        display: flex;
        justify-content: space-evenly;
        width: 98%;
        margin: 9px 0;
        padding: 0;
        align-items: center;
    }
    .selected-energies-info {
        display: block;
        margin-top: 8px;
        margin-bottom: 5px;
    }
    .deck-slots {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        height: 100%;
        align-content: flex-start;
        width: 100%;
        margin: 0;
    }
    .card-slot {
        width: 25%;
        margin-bottom: 10px;
    }
    .card-slot-container {
        position: relative;
        aspect-ratio: 63/88;
        border-radius: 4px;
        overflow: hidden;
        transition: all 0.2s ease;
        display: block;
    }
    .card-slot-container img {
        display: block;
        position: relative;
        z-index: 1;
        width: 100%;
        border-radius: 3.5%;
    }
    .card-slot-container.empty {
        border: 2px dashed var(--border-color);
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: var(--hover-shadow);
    }
    .max-copies img {
        filter: grayscale(85%);
    }
    .empty-slot {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #aaa;
    }
    .empty-slot-text {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-weight: 500;
        color: var(--text-color);
        opacity: 0.7;
    }
    [data-theme="dark"] .empty-slot-text {
        color: var(--text-color);
    }
    .btn-remove-small,
    .btn-remove {
        position: absolute;
        top: 5px;
        right: 5px;
        width: 28px;
        height: 28px;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
        background-color: rgba(220, 53, 69, 0.85);
        color: white;
        border: none;
        border-radius: 50%;
        font-size: 14px;
        transition: all 0.2s ease;
    }
    .btn-remove-small:hover,
    .btn-remove:hover {
        opacity: 1;
        background-color: rgba(176, 42, 55, 0.95);
        transform: scale(1.05);
    }
    .btn-favorite {
        position: absolute;
        top: 5px;
        left: 5px;
        width: 28px;
        height: 28px;
        z-index: 10;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        border: none;
        background: none;
        cursor: pointer;
        color: transparent;
        line-height: 1;
        font-size: 28px;
        transition: transform 0.15s ease-in-out;
    }
    .btn-favorite:hover {
        transform: scale(1.1);
    }
    .btn-favorite i {
        color: #FFFFFF;
        position: relative;
        z-index: 0;
    }
    .btn-favorite.active i {
        color: #FFD700;
        opacity: 1;
        text-shadow: 0 0 3px rgba(0,0,0,0.5);
    }
    [data-theme="dark"] .btn-favorite.active i {
        text-shadow: 0 0 4px rgba(0,0,0,0.7);
    }
    .btn-favorite i.bi-star::before,
    .btn-favorite i.bi-star::after,
    .btn-favorite.active i.bi-star-fill::before {
        font-weight: normal !important;
    }
    .btn-favorite .cover-card-number {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 0.65rem;
        font-weight: bold;
        color: black;
        text-shadow: 0px 0px 2px white, 0px 0px 1px white;
        pointer-events: none;
        line-height: 1;
        z-index: 1;
        margin-top: 1px;
    }
    .card-zoom-container {
        position: fixed;
        display: none;
        z-index: 9999;
        pointer-events: none;
    }
    .card-zoom-container img {
        max-height: 90vh;
        max-width: 340px;
        box-shadow: 0 0 20px rgba(0,0,0,0.5);
        border-radius: 15px;
    }
    [data-theme="dark"] .card-zoom-container img {
        box-shadow: 0 0 20px rgba(255,255,255,0.2);
    }
    .auth-modal {
        display: none;
        position: fixed;
        z-index: 10001;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0,0,0,0.6);
        padding-top: 60px;
    }
    .auth-modal-content {
        background-color: var(--settings-bg, #fefefe);
        color: var(--text-color, #000000);
        margin: 5% auto;
        padding: 25px 30px;
        border: 1px solid var(--border-color, #888);
        width: 80%;
        max-width: 450px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        text-align: center;
    }
    [data-theme="dark"] .auth-modal-content {
        background-color: #2c3136;
        border-color: #444;
    }
    .auth-modal-close-btn {
        color: var(--text-color-muted, #aaa);
        float: right;
        font-size: 28px;
        font-weight: bold;
        line-height: 1;
    }
    .auth-modal-close-btn:hover,
    .auth-modal-close-btn:focus {
        color: var(--text-color, #000);
        text-decoration: none;
        cursor: pointer;
    }
    .auth-modal h2 {
        margin-top: 0;
        margin-bottom: 15px;
        font-weight: 600;
    }
    .auth-modal p {
        margin-bottom: 25px;
        font-size: 1rem;
        line-height: 1.6;
    }
    .auth-modal-actions button {
        padding: 10px 20px;
        margin: 5px;
        min-width: 100px;
        font-weight: 500;
    }
    @keyframes shimmer {
        100% {
            transform: translateX(100%);
        }
    }
    .clickable-card.is-loading {
        display: block;
        position: relative;
        width: 100%;
        aspect-ratio: 63 / 88;
        background-color: #e0e0e0;
        border-radius: 3.5%;
        overflow: hidden;
    }
    .clickable-card.is-loading::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
        transform: translateX(-100%);
        animation: shimmer 1.5s infinite;
        /* Prevent animation restart on DOM changes */
        animation-fill-mode: both;
    }
    .clickable-card.is-loading::before {
        content: none !important;
    }
    [data-theme="dark"] .clickable-card.is-loading {
        background-color: #3a3f44;
    }
    [data-theme="dark"] .clickable-card.is-loading::after {
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.08), transparent);
        /* Prevent animation restart on DOM changes */
        animation-fill-mode: both;
    }
    .clickable-card.is-loading > img {
        opacity: 0;
    }
    .clickable-card.is-loaded > img {
        opacity: 1;
        transition: opacity 0.2s ease-in-out;
    }

    /* Card collection skeleton loading effects - matches collection.html style */
    .card-skeleton-container {
        position: relative;
        margin-bottom: 7px;
    }
    
    .card-skeleton {
        display: block;
        position: relative;
        width: 100%;
        aspect-ratio: 63 / 88;
        background-color: #f0f0f0;
        border-radius: 3.5%;
        overflow: hidden;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    
    .card-skeleton::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
        transform: translateX(-100%);
        animation: shimmer 1.5s infinite;
    }
    
    [data-theme="dark"] .card-skeleton {
        background-color: #3a3f44;
    }
    
    [data-theme="dark"] .card-skeleton::after {
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.15), transparent);
    }
    :root:not([data-theme="dark"]) {
        .current-deck-container .input-group #deck-name {
            background-color: var(--input-bg, #f1f1f1);
            border-color: var(--border-color, #dee2e6);
            border-top-right-radius: 0.375rem;
            border-bottom-right-radius: 0.375rem;
        }
        .current-deck-container .deck-counter {
            background-color: var(--input-bg, #f1f1f1) !important;
            color: var(--text-color, #212529) !important;
            box-shadow: none !important;
            border: 1px solid var(--border-color, #dee2e6);
            border-left: 1px solid transparent;
        }
        #clear-deck-btn {
            background-color: transparent;
            border-color: var(--border-color, #dee2e6);
            color: var(--bs-danger, #dc3545);
        }
        #clear-deck-btn:hover {
            background-color: rgba(220, 53, 69, 0.1);
        }
        .filter-label,
        .filter-label-top,
        .filter-label-top-color {
            color: #6c757d;
            opacity: 1;
        }
    }
    [data-theme="dark"] .current-deck-container .input-group #deck-name {
        border-top-right-radius: 0.375rem;
        border-bottom-right-radius: 0.375rem;
    }
    @keyframes card-click-effect {
        50% {
            transform: scale(1);
        }
    }
    .card-item.is-clicking {
        animation: card-click-effect 0.12s ease-out;
    }
    #sort-options-dropdown.dropdown-menu {
        width: max-content !important;
        min-width: auto !important;
    }
    @media (min-width: 1430px) {
        .filter-bar .row {
            flex-direction: row;
            align-items: flex-start;
        }
        .filter-bar .col-md-8 {
            width: 70%;
        }
        .filter-bar .col-md-4 {
            width: 30%;
            padding-bottom: 0;
            padding-top: 2px;
        }
        .filter-bar .col-md-3 {
            flex: 0 0 25%;
            margin-bottom: 0;
        }
        .filter-bar .col-md-8 .row {
            flex-wrap: nowrap;
        }
    }
    @media (max-width: 1429px) and (min-width: 800px) {
        .filter-bar .row {
            flex-direction: row;
            align-items: flex-start;
        }
        .filter-bar .col-md-8 {
            width: 70%;
        }
        .filter-bar .col-md-4 {
            width: 30%;
            height: 100%;
            align-self: center;
        }
        .filter-bar .col-md-8 .row {
            flex-wrap: wrap;
        }
        .filter-bar .col-md-3 {
            flex: 0 0 50%;
            margin-bottom: 10px;
        }
        .filter-bar .col-md-3:nth-child(1),
        .filter-bar .col-md-3:nth-child(2) {
            margin-bottom: 10px;
        }
        .filter-bar .col-md-3:nth-child(3),
        .filter-bar .col-md-3:nth-child(4) {
            margin-bottom: 0;
        }
        .filter-bar .energy-icons {
            width: 100%;
            max-width: 100%;
            display: flex;
            flex-wrap: wrap;
            margin-top: 4px;
        }
    }
    @media (max-width: 1300px) and (min-width: 800px) {
        .deck-builder-main-row {
            display: flex;
            flex-wrap: wrap;
            margin-right: 0;
            margin-left: 0;
        }
        .add-cards-wrapper {
            flex-grow: 1;
            flex-shrink: 1;
            width: calc(100% - 398px);
            min-width: 0;
            flex-basis: auto;
            padding-left: 0;
        }
        .current-deck-wrapper {
            width: 398px;
            flex-shrink: 0 !important;
            padding-right: 0 !important;
            margin-left: 0;
            flex-basis: auto !important;
        }
        .add-cards-wrapper .card,
        .current-deck-wrapper .card {
            display: flex !important;
            flex-direction: column !important;
            height: 100% !important;
        }
        .add-cards-wrapper .card-body,
        .current-deck-wrapper .card-body {
            flex-grow: 1;
            overflow: hidden;
            position: relative;
        }
        .add-cards-wrapper #card-collection,
        .current-deck-wrapper #current-deck {
            height: 100%;
            overflow-y: auto;
        }
    }
    @media (max-width: 800px) {
        .filter-bar {
            width: 100%;
            padding-left: 8px;
            padding-right: 8px;
        }
        .filter-bar .row {
            margin-right: 0;
            margin-left: 0;
        }
        .filter-bar .col-md-8,
        .filter-bar .col-md-4 {
            padding: 0 5px;
        }
        .filter-bar .dropdown button {
            width: 100%;
            min-width: 80px;
            min-height: 44px;
        }
        .filter-bar .row {
            flex-direction: column;
        }
        .filter-bar .col-md-8,
        .filter-bar .col-md-4 {
            width: 100%;
        }
        .filter-bar .col-md-8 {
            margin-bottom: 10px;
        }
        .filter-bar .col-md-8 .row {
            flex-direction: column;
            width: 100%;
        }
        .filter-bar .col-md-3 {
            flex: 0 0 100%;
            margin-bottom: 10px;
            width: 100%;
        }
        .filter-bar .col-md-3:last-child {
            margin-bottom: 0;
        }
        .row.mb-4 {
            flex-direction: column;
        }
        .col-md-8.mb-4,
        .col-md-4.mb-4 {
            display: block !important;
            flex: none !important;
            max-width: 100% !important;
            width: 100% !important;
            margin-bottom: 1rem !important;
            min-height: 300px;
        }
        .add-cards-wrapper .card,
        .current-deck-wrapper .card {
            height: auto;
            min-height: 620px;
        }
        .current-deck-wrapper #current-deck {
            height: auto;
        }
        .deck-builder-main-row {
            display: block;
        }
        .card-zoom-container img {
            max-width: 260px;
        }
    }
    @media (hover: none) {
        /* --- General Mobile Hover Resets --- */
        .card-item:hover,
        .btn-favorite:hover,
        .btn-remove-small:hover,
        .btn-remove:hover,
        .card-item:hover .badge {
            transform: none;
        }
        .card-item:hover img {
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .btn-remove-small:hover,
        .btn-remove:hover {
            background-color: rgba(220, 53, 69, 0.85);
        }
        .energy-icon-wrapper:hover:not(.active) { 
            opacity: 0.5; 
            filter: saturate(0.8); 
        }
        .auth-modal-close-btn:hover, .auth-modal-close-btn:focus { 
            color: var(--text-color-muted, #aaa); 
            text-decoration: none; 
        }
        #card-collection::-webkit-scrollbar-thumb:hover { 
            background: #888; 
        }
        [data-theme="dark"] #card-collection::-webkit-scrollbar-thumb:hover { 
            background: var(--border-color); 
        }

        /* --- Mobile Tap Animations & Effects --- */
        .card-item {
            -webkit-tap-highlight-color: transparent;
        }
        .clickable-card::before {
            content: '+';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 36px;
            height: 36px;
            background-color: rgba(40, 40, 40, 0.8);
            color: #2ecc71;
                display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.9;
            z-index: 10;
            padding-bottom: 4px;
            font-weight: bold;
            font-size: 24px;
            pointer-events: none;
        }
        @keyframes mobile-card-tap-animation {
            50% { transform: scale(0.95); }
        }
        .clickable-card.tapped-mobile {
            animation: mobile-card-tap-animation 0.12s ease-in-out;
        }
        .btn-remove.is-tapping,
        .btn-remove-small.is-tapping {
            animation: mobile-card-tap-animation 0.17s ease-in-out;
        }
        
        /* Enhanced loading indicators for image loading states */
        .card-item.loading-high-res,
        .clickable-card.loading-high-res {
            position: relative;
        }
        
        .card-item.loading-high-res::after,
        .clickable-card.loading-high-res::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            border: 2px solid rgba(255,255,255,0.2);
            border-top-color: #007bff;
                animation: spin 0.8s linear infinite;
            z-index: 10;
            pointer-events: none;
            background: rgba(0,0,0,0.5);
        }

        /* Different loading states */
        .card-item.loading-queued::before {
            content: '';
            position: absolute;
            top: 5px;
            right: 5px;
            width: 8px;
            height: 8px;
            background: #ffc107;
                z-index: 5;
            animation: pulse 2s infinite;
        }

        .card-item.loading-priority::before {
            background: #28a745;
        }

        .card-item.loading-deck::before {
            background: #dc3545;
        }
        
        @keyframes spin {
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }

        /* Batch loading progress indicator */
        .batch-progress {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.8rem;
            z-index: 1000;
            opacity: 0;
        }

        .batch-progress.visible {
            opacity: 1;
        }

        .batch-progress .progress-bar {
            width: 100px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            margin-top: 4px;
            overflow: hidden;
        }

        .batch-progress .progress-fill {
            height: 100%;
            background: #007bff;
            border-radius: 2px;
        }
        
        #save-deck-btn, #clear-deck-btn {
            -webkit-tap-highlight-color: transparent;
        }
        #save-deck-btn:hover,
        #save-deck-btn:active {
            transform: none !important;
            box-shadow: none !important;
            background-color: #198754 !important;
            border-color: #198754 !important;
            color: white !important;
        }
        #clear-deck-btn:hover,
        #clear-deck-btn:active {
            transform: none !important;
            box-shadow: none !important;
            background-color: transparent !important;
            color: #dc3545 !important;
        }
        #save-deck-btn:focus,
        #clear-deck-btn:focus {
            box-shadow: none !important;
        }
        .btn-outline-secondary:hover,
        .btn-outline-secondary:active,
        .btn-outline-secondary:focus {
            color: var(--bs-secondary) !important;
            background-color: transparent !important;
            box-shadow: none !important;
        }
    }
    @media (min-width: 451px) {
        #deck-name {
            border-radius: 8px 0 0 8px !important;
        }
    }
    @media (max-width: 450px) {
        .filter-bar .row {
            justify-content: space-between;
        }
        .filter-bar .col-md-8 .row {
            flex-direction: row;
            flex-wrap: wrap;
            gap: 15px 0;
        }
        .filter-bar .col-md-3 {
            flex: 1 0 48%;
            max-width: 48%;
            margin-bottom: 0;
            display: flex;
            flex-direction: column;
            padding: 0 5px 0 3px;
        }
        .filter-bar .col-md-4 {
            padding: 0 3px;
            padding-left: 11px;
        }
        .filter-bar .col-md-4 .filter-label-top {
            margin-left: -3px;
        }
        .filter-bar .col-md-3 .dropdown {
            margin-top: auto;
        }
        .filter-bar .col-md-3:nth-child(3) {
            flex-grow: 0.5;
        }
        .filter-bar .col-md-3:nth-child(4) {
            flex-grow: 1.5;
        }
        .filter-bar .energy-icons {
            display: flex;
            justify-content: flex-start;
            gap: 6px;
            padding-left: 0;
            width: 100%;
            margin-left: 0;
            margin-right: 0;
            flex-wrap: nowrap;
            overflow-x: auto;
            -ms-overflow-style: none;
            scrollbar-width: none;
            margin-top: 2px;
            padding: 9px 0;
        }
        .filter-bar .energy-icon-wrapper {
            width: 22px;
            height: 22px;
            flex-shrink: 0;
        }
        .col-md-8.mb-4 .card-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .col-md-8.mb-4 .card-header .input-group {
            flex: 1 1 auto;
            min-width: 120px;
        }
        .current-deck-container .card-header .input-group {
            flex-wrap: wrap;
            gap: 0.5rem 0;
        }
        .current-deck-container .card-header #deck-name {
            flex-basis: 100%;
                margin-bottom: 5px;
        }
        .current-deck-container .card-header .btn,
        .current-deck-container .card-header .deck-counter {
            flex-grow: 1;
            border-radius: 0 !important;
        }
        .current-deck-container .card-header #save-deck-btn {
            border-top-left-radius: 8px !important;
            border-bottom-left-radius: 8px !important;
        }
        .current-deck-container .card-header .deck-counter {
            border-top-right-radius: 8px !important;
            border-bottom-right-radius: 8px !important;
        }
        .col-md-8.mb-4 .card-header .dropdown {
            width: 75px;
            min-width: 75px;
        }
        .col-md-8.mb-4 .card-header .dropdown button {
            padding: 10px 12px;
        }
        .col-md-8.mb-4 .card-header .dropdown .dropdown-toggle::after {
            display: none;
        }
        .energy-selection-bar {
            justify-content: space-between;
            padding: 4px 0;
        }
        .energy-selection-bar .energy-label {
            margin-right: 6px;
        }
        .energy-selection-bar .energy-icon-wrapper.deck-energy {
            width: 22px;
            height: 22px;
            margin: 0 1px;
        }
        .current-deck-wrapper .card,
        .current-deck-wrapper .card-body {
            overflow-x: hidden;
        }
        .filter-label-top,
        .filter-label-top-color {
            margin-bottom: 4px;
            min-height: 0;
        }
        #search-input {
            font-size: 16px; /* Prevents iOS zoom on focus */
        }
        #search-input::placeholder {
            font-size: 0.875rem;
        }

        #card-count-search {
            font-size: 0.8rem;
        }
        .filter-container {
            min-height: auto;
        }
    }


    /* Desktop hover effects for filter dropdowns */
    #cardTypeDropdown:hover,
    #cardTypeDropdown[aria-expanded="true"],
    #stageTypeDropdown:hover,
    #stageTypeDropdown[aria-expanded="true"],
    #setDropdown:hover,
    #setDropdown[aria-expanded="true"],
    #rarityDropdown:hover,
    #rarityDropdown[aria-expanded="true"] {
        background-color: rgba(0, 0, 0, 0.15) !important;
        border-color: var(--border-color) !important;
        color: var(--text-color) !important;
    }

    /* Dark mode compatibility for filter dropdowns */
    [data-theme="dark"] #cardTypeDropdown:hover,
    [data-theme="dark"] #cardTypeDropdown[aria-expanded="true"],
    [data-theme="dark"] #stageTypeDropdown:hover,
    [data-theme="dark"] #stageTypeDropdown[aria-expanded="true"],
    [data-theme="dark"] #setDropdown:hover,
    [data-theme="dark"] #setDropdown[aria-expanded="true"],
    [data-theme="dark"] #rarityDropdown:hover,
    [data-theme="dark"] #rarityDropdown[aria-expanded="true"] {
        background-color: rgba(255, 255, 255, 0.15) !important;
        border-color: var(--border-color) !important;
        color: var(--text-color) !important;
    }

    /* Mobile-only: Remove all visual effects from filter dropdown buttons */
    @media (hover: none) {
        #cardTypeDropdown,
        #stageTypeDropdown,
        #setDropdown,
        #rarityDropdown {
            -webkit-tap-highlight-color: transparent !important;
        }
        
        #cardTypeDropdown:hover,
        #cardTypeDropdown:active,
        #cardTypeDropdown:focus,
        #cardTypeDropdown[aria-expanded="true"],
        #cardTypeDropdown.show,
        #stageTypeDropdown:hover,
        #stageTypeDropdown:active,
        #stageTypeDropdown:focus,
        #stageTypeDropdown[aria-expanded="true"],
        #stageTypeDropdown.show,
        #setDropdown:hover,
        #setDropdown:active,
        #setDropdown:focus,
        #setDropdown[aria-expanded="true"],
        #setDropdown.show,
        #rarityDropdown:hover,
        #rarityDropdown:active,
        #rarityDropdown:focus,
        #rarityDropdown[aria-expanded="true"],
        #rarityDropdown.show {
            background-color: var(--bs-btn-bg) !important;
            border-color: var(--bs-btn-border-color) !important;
            color: var(--bs-btn-color) !important;
            box-shadow: none !important;
            transform: none !important;
            filter: none !important;
            opacity: 1 !important;
        }
    }
</style>
{% endblock %}

{% block content %}
{# HTML SECTION #}
<body>
    <!-- Batch loading progress indicator -->
    <div id="batch-progress" class="batch-progress">
        <div id="batch-progress-text">Loading images...</div>
        <div class="progress-bar">
            <div id="batch-progress-fill" class="progress-fill" style="width: 0%"></div>
        </div>
    </div>

    <div class="container">
        <div class="container-fluid">
            <div class="filter-bar mb-4 rounded">
                <div class="row align-items-start">
                    <div class="col-md-8">
                        <div class="row">
                            <div class="col-md-3">
                                <div class="filter-container">
                                    <div class="filter-label-top">Card Type</div>
                                    <div class="dropdown w-100">
                                        <button class="btn btn-outline-secondary dropdown-toggle w-100" type="button" id="cardTypeDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                                            <span class="btn-text">All</span>
                                        </button>
                                        <ul class="dropdown-menu w-100" id="card-type-dropdown">
                                            <li><a class="dropdown-item active" href="#" data-value="All">All</a></li>
                                            <li><a class="dropdown-item" href="#" data-value="Pokémon">Pokémon</a></li>
                                            <li><a class="dropdown-item" href="#" data-value="Trainer">Trainer</a></li>
                                        </ul>
                                    </div>
                                </div>
                            </div>

                            <div class="col-md-3">
                                <div class="filter-container">
                                    <div class="filter-label-top">Stage/Trainer</div>
                                    <div class="dropdown w-100">
                                        <button class="btn btn-outline-secondary dropdown-toggle w-100" type="button" id="stageTypeDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                                            <span class="btn-text">All</span>
                                        </button>
                                        <ul class="dropdown-menu w-100" id="stage-type-dropdown">
                                            <li><a class="dropdown-item active" href="#" data-value="All">All</a></li>
                                            <li><a class="dropdown-item" href="#" data-value="Supporter">Supporter</a></li>
                                            <li><a class="dropdown-item" href="#" data-value="Basic">Basic</a></li>
                                            <li><a class="dropdown-item" href="#" data-value="Stage 1">Stage 1</a></li>
                                            <li><a class="dropdown-item" href="#" data-value="Stage 2">Stage 2</a></li>
                                            <li><a class="dropdown-item" href="#" data-value="EX">EX</a></li>
                                            <li><a class="dropdown-item" href="#" data-value="Ultra Beast">Ultra Beast</a></li>
                                            <li><a class="dropdown-item" href="#" data-value="Item">Item</a></li>
                                            <li><a class="dropdown-item" href="#" data-value="Tool">Tool</a></li>
                                        </ul>
                                    </div>
                                </div>
                            </div>

                            <div class="col-md-3">
                                <div class="filter-container">
                                    <div class="filter-label-top">Set</div>
                                    <div class="dropdown w-100">
                                        <button class="btn btn-outline-secondary dropdown-toggle w-100" type="button" id="setDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                                            <span class="btn-text">All</span>
                                        </button>
                                        <ul class="dropdown-menu w-100" id="set-dropdown">
                                            </ul>
                                    </div>
                                </div>
                            </div>

                            <div class="col-md-3">
                                <div class="filter-container">
                                    <div class="filter-label-top">Rarity</div>
                                    <div class="dropdown w-100">
                                        <button class="btn btn-outline-secondary dropdown-toggle w-100" type="button" id="rarityDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                                            <span class="btn-text">All</span>
                                        </button>
                                        <ul class="dropdown-menu w-100" id="rarity-dropdown">
                                            <li><a class="dropdown-item active" href="#" data-value="All">All</a></li>
                                            <li><a class="dropdown-item" href="#" data-value="◊">◊</a></li>
                                            <li><a class="dropdown-item" href="#" data-value="◊◊">◊◊</a></li>
                                            <li><a class="dropdown-item" href="#" data-value="◊◊◊">◊◊◊</a></li>
                                            <li><a class="dropdown-item" href="#" data-value="◊◊◊◊">◊◊◊◊</a></li>
                                            <li><a class="dropdown-item" href="#" data-value="☆">☆</a></li>
                                            <li><a class="dropdown-item" href="#" data-value="☆☆">☆☆</a></li>
                                            <li><a class="dropdown-item" href="#" data-value="☆☆☆">☆☆☆</a></li>
                                            <li><a class="dropdown-item" href="#" data-value='✵'>✵</a></li>
                                            <li><a class="dropdown-item" href="#" data-value='✵✵'>✵✵</a></li>
                                            <li><a class="dropdown-item" href="#" data-value="Crown Rare">👑</a></li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="col-md-4">
                        <div class="filter-label-top">Color</div>
                        <div class="energy-icons">
                            {% set energy_types_for_filter = ["Grass", "Fire", "Water", "Lightning", "Psychic", "Fighting", "Darkness", "Metal", "Dragon", "Colorless"] %}
                            {% set energy_type_filenames = {
                                "Grass": "grass.png", "Fire": "fire.png", "Water": "water.png", 
                                "Lightning": "electric.png", "Psychic": "psychic.png", 
                                "Fighting": "fighting.png", "Darkness": "dark.png", 
                                "Metal": "metal.png", "Dragon": "dragon.png", "Colorless": "colorless.png"
                            } %}

                            {% for type_name in energy_types_for_filter %}
                            <div class="energy-icon-wrapper" data-type="{{ type_name }}">
                                {% if config.ENERGY_ICON_URLS and config.ENERGY_ICON_URLS.get(type_name) %}
                                    <img src="{{ config.ENERGY_ICON_URLS.get(type_name) }}" alt="{{ type_name }}" class="energy-icon" data-energy-type="{{ type_name }}" onerror="this.style.display='none'">
                                {% else %}
                                    <span class="energy-fallback-text-small" title="{{ type_name }}">{{ type_name[0] if type_name else '?' }}</span>
                                {% endif %}
                            </div>
                            {% endfor %}
                        </div>
                    </div>
                </div>
            </div>

            <div class="row deck-builder-main-row">
                <div class="col-md-8 mb-4 add-cards-wrapper">
                    <div class="card">
                        <div class="card-header d-flex align-items-center gap-2"> <div class="input-group flex-grow-1">
                                <span class="input-group-text"><i class="bi bi-search"></i></span>
                                <input type="text" id="search-input" class="form-control" placeholder="Search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
                                <span id="card-count-search" class="input-group-text">0 cards</span>
                            </div>

                            <div class="dropdown"> <button class="btn btn-outline-secondary dropdown-toggle w-100" type="button" id="sortDropdownButton" data-bs-toggle="dropdown" aria-expanded="false">
                                </button>
                                <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="sortDropdownButton" id="sort-options-dropdown">
                                    <li>
                                        <a class="dropdown-item" href="#" data-sort-type="set" data-default-direction="desc">
                                            Set <span class="sort-arrow"></span>
                                        </a>
                                    </li>
                                    <li>
                                        <a class="dropdown-item" href="#" data-sort-type="rarity" data-default-direction="asc">
                                            Rarity <span class="sort-arrow"></span>
                                        </a>
                                    </li>
                                    <li>
                                        <a class="dropdown-item" href="#" data-sort-type="type" data-default-direction="asc">
                                            Type <span class="sort-arrow"></span>
                                        </a>
                                    </li>
                                    <li>
                                        <a class="dropdown-item" href="#" data-sort-type="name" data-default-direction="asc">
                                            Name <span class="sort-arrow"></span>
                                        </a>
                                    </li>
                                    </ul>
                            </div>
                        </div>
                        <div class="card-body">
                            <div id="card-collection">
                                <!-- Initial shimmer cards to prevent gray screen -->
                                <div class="row g-2">
                                    {% for i in range(12) %}
                                    <div class="col-4 col-sm-4 col-md-4 col-lg-3 col-xl-2 mb-3 card-item">
                                        <div class="position-relative clickable-card is-loading">
                                        </div>
                                    </div>
                                    {% endfor %}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                    <div class="col-md-4 mb-4 current-deck-container current-deck-wrapper">
                    <div class="card">
                        <div class="card-header">
                            <div class="input-group mb-2">
                                <input type="text" id="deck-name" class="form-control" placeholder="Enter Deck Name" autocomplete="off">
                                <button id="save-deck-btn" class="btn btn-success">Save</button>
                                <button id="clear-deck-btn" class="btn btn-outline-danger">Clear</button>
                                <span class="deck-counter">0/20</span>
                            </div>
                            {% set deck_energy_selectable_types = [
                                "Grass", "Fire", "Water", "Lightning", 
                                "Psychic", "Fighting", "Darkness", "Metal"
                            ] %}
                            <div class="energy-selection-bar d-flex flex-wrap">
                                <label class="energy-label">Energy:</label>
                                {% for type_name in deck_energy_selectable_types %}
                                <div class="energy-icon-wrapper deck-energy" data-type="{{ type_name }}">
                                    {% if config.ENERGY_ICON_URLS and config.ENERGY_ICON_URLS.get(type_name) %}
                                        <img src="{{ config.ENERGY_ICON_URLS.get(type_name) }}" 
                                            alt="{{ type_name }}" 
                                            class="energy-icon" 
                                            data-energy-type="{{ type_name }}" 
                                            onerror="this.style.display='none';">
                                    {% endif %}
                                </div>
                                {% endfor %}
                            </div>
                        </div>
                        <div class="card-body">
                            <div id="current-deck" class="deck-slots">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="card-zoom-container" id="card-zoom-container"></div>
        <div id="loginToSaveModal" class="auth-modal" style="display: none;">
            <div class="auth-modal-content">
                <span class="auth-modal-close-btn" style="cursor: pointer;" title="Close">&times;</span>
                <h2>Save Your Deck</h2>
                <p>Please sign in with your Google account to save your deck. Your current deck progress has been temporarily remembered!</p>
                <div class="auth-modal-actions" style="margin-top: 20px;">
                    <button id="loginToSaveModal_googleBtn" class="btn btn-danger btn-lg">
                        <i class="fab fa-google" style="margin-right: 8px;"></i>Sign in with Google & Save
                    </button>
                </div>
            </div>
        </div>
    </div>
</body>
{% endblock %}

{% block extra_js %}
{# JAVASCRIPT #}
<script>
    
    let allCards = [];
    let filteredCards = []; // For backward compatibility with existing code
    let currentDeck = [];
    let coverCardIds = [];
    let loadedDeckId = null;
    let selectedFilters = { 
        cardType: 'All',
        stageType: 'All',
        rarity: 'All',
        set: 'All',
        energyTypes: [] 
    };
    let rawSearchText = ''; 
    let typedEnergyTypes = new Set(); // Track energy types selected via typing
    let typedFilters = new Set(); // Track which filters were set via typing
    let deckSaved = false;
    let cardObserver = null;
    let loadTimeout = null;
    
    let currentPage = 1;
    let isLoading = false;
    let hasMoreCards = true;
    let loadedIds = new Set();
    
    function debounce(func, delay) {
        let timeoutId;
        return function(...args) {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => func.apply(this, args), delay);
        };
    }

    // Mobile deck auto-save storage management
    function clearAutoSavedData() {
        try {
            sessionStorage.removeItem('autoSavedDeck');
            localStorage.removeItem('autoSavedDeck_persistent');
            console.log('Cleared auto-saved deck data');
        } catch (error) {
            console.warn('Failed to clear auto-saved data:', error);
        }
    }

    function getStorageUsage() {
        try {
            const usage = {
                sessionStorage: 0,
                localStorage: 0,
                total: 0
            };

            // Calculate session storage usage
            for (let key in sessionStorage) {
                if (sessionStorage.hasOwnProperty(key)) {
                    usage.sessionStorage += sessionStorage[key].length;
                }
            }

            // Calculate local storage usage
            for (let key in localStorage) {
                if (localStorage.hasOwnProperty(key)) {
                    usage.localStorage += localStorage[key].length;
                }
            }

            usage.total = usage.sessionStorage + usage.localStorage;
            return usage;
        } catch (error) {
            console.warn('Failed to calculate storage usage:', error);
            return { sessionStorage: 0, localStorage: 0, total: 0 };
        }
    }

    function cleanupExpiredAutoSaves() {
        try {
            const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days
            const persistentData = localStorage.getItem('autoSavedDeck_persistent');
            
            if (persistentData) {
                const parsed = JSON.parse(persistentData);
                if (parsed.timestamp && (Date.now() - parsed.timestamp) > maxAge) {
                    localStorage.removeItem('autoSavedDeck_persistent');
                    console.log('Cleaned up expired auto-save data');
                }
            }
        } catch (error) {
            console.warn('Failed to cleanup expired auto-saves:', error);
        }
    }

    function triggerMobileAutoSave() {
        // Save if deck has cards OR energy types selected (to preserve energy selection even without cards)
        if (!deckSaved && loadedDeckId === null && (currentDeck.length > 0 || selectedDeckEnergies.length > 0)) {
            try {
                const deckData = {
                    name: document.getElementById('deck-name').value,
                    cards: currentDeck.map(c => ({ id: c.id })),
                    deck_types: selectedDeckEnergies,
                    cover_card_ids: coverCardIds,
                    timestamp: Date.now(),
                    version: '2.0'
                };
                
                // Save to both session and local storage
                sessionStorage.setItem('autoSavedDeck', JSON.stringify(deckData));
                localStorage.setItem('autoSavedDeck_persistent', JSON.stringify(deckData));
                
                console.log('Mobile auto-save triggered:', {
                    deckName: deckData.name,
                    cardCount: deckData.cards.length,
                    energyTypes: selectedDeckEnergies,
                    coverCards: coverCardIds,
                    timestamp: new Date(deckData.timestamp).toLocaleString()
                });
            } catch (error) {
                console.warn('Failed to trigger mobile auto-save:', error);
            }
        }
    }
    
    class ImageCacheManager {
        constructor() {
            this.cacheKey = 'pokemon_tcg_high_res_cache_v2';
            this.metadataKey = 'pokemon_tcg_cache_metadata_v2';
            this.maxCacheSize = 300; // Increased cache size
            this.maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds
            this.cache = new Map();
            this.loadFromStorage();
        }

        loadFromStorage() {
            try {
                const cacheData = localStorage.getItem(this.cacheKey);
                const metadata = localStorage.getItem(this.metadataKey);
                
                if (cacheData && metadata) {
                    const cache = JSON.parse(cacheData);
                    const meta = JSON.parse(metadata);
                    const now = Date.now();
                    
                    for (const [url, timestamp] of Object.entries(cache)) {
                        if (now - timestamp < this.maxAge) {
                            this.cache.set(url, {
                                timestamp,
                                size: meta[url]?.size || 0,
                                loadCount: meta[url]?.loadCount || 1
                            });
                        }
                    }
                    
                }
            } catch (error) {
                this.cache.clear();
            }
        }

        saveToStorage() {
            try {
                const cacheData = {};
                const metadata = {};
                
                for (const [url, data] of this.cache) {
                    cacheData[url] = data.timestamp;
                    metadata[url] = {
                        size: data.size,
                        loadCount: data.loadCount
                    };
                }
                
                localStorage.setItem(this.cacheKey, JSON.stringify(cacheData));
                localStorage.setItem(this.metadataKey, JSON.stringify(metadata));
            } catch (error) {
            }
        }

        has(url) {
            const entry = this.cache.get(url);
            if (!entry) return false;
            
            if (Date.now() - entry.timestamp > this.maxAge) {
                this.cache.delete(url);
                return false;
            }
            
            return true;
        }

        add(url, size = 0) {
            const now = Date.now();
            
            if (this.cache.has(url)) {
                const entry = this.cache.get(url);
                entry.loadCount++;
                entry.timestamp = now; // Update timestamp for LRU
            } else {
                this.cache.set(url, {
                    timestamp: now,
                    size,
                    loadCount: 1
                });
            }
            
            this.manageSize();
            this.saveToStorage();
        }

        delete(url) {
            const deleted = this.cache.delete(url);
            if (deleted) {
                this.saveToStorage();
            }
            return deleted;
        }

        get size() {
            return this.cache.size;
        }

        manageSize() {
            if (this.cache.size <= this.maxCacheSize) return;
            
            const entries = Array.from(this.cache.entries());
            entries.sort((a, b) => {
                const [, dataA] = a;
                const [, dataB] = b;
                
                if (dataA.loadCount !== dataB.loadCount) {
                    return dataA.loadCount - dataB.loadCount;
                }
                
                return dataA.timestamp - dataB.timestamp;
            });
            
            const toRemove = Math.ceil(entries.length * 0.25);
            for (let i = 0; i < toRemove; i++) {
                this.cache.delete(entries[i][0]);
            }
            
        }

        clear() {
            this.cache.clear();
            localStorage.removeItem(this.cacheKey);
            localStorage.removeItem(this.metadataKey);
        }

        getStats() {
            const now = Date.now();
            let totalSize = 0;
            let recentCount = 0;
            
            for (const [, data] of this.cache) {
                totalSize += data.size;
                if (now - data.timestamp < 24 * 60 * 60 * 1000) { // Last 24 hours
                    recentCount++;
                }
            }
            
            return {
                totalEntries: this.cache.size,
                recentEntries: recentCount,
                estimatedSizeMB: (totalSize / (1024 * 1024)).toFixed(2),
                maxCacheSize: this.maxCacheSize,
                maxAge: this.maxAge
            };
        }
    }

    function getHighResUrl(originalUrl) {
        if (!originalUrl) return null;
        
        if (originalUrl.includes('/cards/')) {
            return originalUrl.replace('/cards/', '/high_res_cards/');
        }
        
        return null;
    }

    // Image URL helper - convert Firebase Storage URLs to CDN URLs
    function getImageUrl(originalUrl) {
        if (!originalUrl) return '';
        
        // If the URL already includes the CDN domain, return as-is
        if (originalUrl.startsWith('https://cdn.pvpocket.xyz')) {
            return originalUrl;
        }
        
        if (originalUrl.includes('firebasestorage.googleapis.com') || originalUrl.includes('storage.googleapis.com')) {
            // Extract the path from Firebase Storage URLs
            // Examples:
            // https://firebasestorage.googleapis.com/v0/b/pvpocket-dd286.firebasestorage.app/o/energy_icons%2Fwater.png?alt=media
            // https://storage.googleapis.com/pvpocket-dd286.firebasestorage.app/cards/genetic-apex/267
            
            let path = '';
            
            if (originalUrl.includes('firebasestorage.googleapis.com')) {
                // Handle Firebase Storage URLs with encoded paths
                const pathMatch = originalUrl.match(/\/o\/([^?]+)/);
                if (pathMatch) {
                    path = '/' + decodeURIComponent(pathMatch[1]);
                }
            } else if (originalUrl.includes('storage.googleapis.com')) {
                // Handle Google Cloud Storage URLs  
                const pathMatch = originalUrl.match(/pvpocket-dd286\.firebasestorage\.app\/(.+)$/);
                if (pathMatch) {
                    path = '/' + pathMatch[1];
                }
            }
            
            if (path) {
                return 'https://cdn.pvpocket.xyz' + path;
            }
        }
        
        // If it's a relative path, prepend the CDN base URL
        if (originalUrl.startsWith('/') || !originalUrl.includes('://')) {
            return 'https://cdn.pvpocket.xyz' + (originalUrl.startsWith('/') ? originalUrl : '/' + originalUrl);
        }
        
        return originalUrl;
    }

    class BatchLoadManager {
        constructor() {
            this.maxConcurrent = 3; // Maximum concurrent high-res loads
            this.batchDelay = 300; // Delay between batches (ms)
            this.priorityQueues = {
                deck: [], // Deck cards get highest priority
                visible: [], // Visible collection cards
                background: [] // Background collection cards
            };
            this.activeLoads = new Set();
            this.isProcessing = false;
            this.totalProcessed = 0;
        }

        addToPriorityQueue(item, priority = 'background') {
            // Don't add if already queued or loading
            if (this.isInAnyQueue(item.originalSrc) || this.activeLoads.has(item.originalSrc)) {
                return;
            }

            this.addLoadingState(item, priority);
            
            this.priorityQueues[priority].push(item);
            this.scheduleProcessing();
            this.updateProgressIndicator();
        }

        isInAnyQueue(originalSrc) {
            return Object.values(this.priorityQueues).some(queue => 
                queue.some(item => item.originalSrc === originalSrc)
            );
        }

        scheduleProcessing() {
            if (this.isProcessing) return;
            
            this.isProcessing = true;
            requestAnimationFrame(() => this.processBatch());
        }

        async processBatch() {
            while (this.activeLoads.size < this.maxConcurrent && this.hasQueuedItems()) {
                const item = this.getNextItem();
                if (!item) break;

                this.activeLoads.add(item.originalSrc);
                this.loadHighResImage(item).finally(() => {
                    this.activeLoads.delete(item.originalSrc);
                    if (this.hasQueuedItems()) {
                        setTimeout(() => this.processBatch(), this.batchDelay);
                    } else {
                        this.isProcessing = false;
                    }
                });
            }

            if (!this.hasQueuedItems() && this.activeLoads.size === 0) {
                this.isProcessing = false;
            }
        }

        hasQueuedItems() {
            return Object.values(this.priorityQueues).some(queue => queue.length > 0);
        }

        getNextItem() {
            // Process in priority order: deck -> visible -> background
            for (const priority of ['deck', 'visible', 'background']) {
                if (this.priorityQueues[priority].length > 0) {
                    return this.priorityQueues[priority].shift();
                }
            }
            return null;
        }

        async loadHighResImage(item) {
            const { img, originalSrc, highResSrc, highResProxyUrl } = item;
            
            try {
                item.container?.classList.add('loading-high-res');
                
                if (highResImageCache.has(highResSrc)) {
                    img.src = highResProxyUrl;
                    img.dataset.loadedResolution = 'high';
                    imageLoadingStats.hits++;
                    this.updateMatchingImages(originalSrc, highResProxyUrl);
                    this.removeLoadingState(item);
                    this.totalProcessed = (this.totalProcessed || 0) + 1;
                    this.updateProgressIndicator();
                    return true;
                }

                const success = await loadImageWithDeduplication(highResProxyUrl, highResSrc);
                if (success && img.parentElement && !img.dataset.replacedByHover) {
                    img.src = highResProxyUrl;
                    img.dataset.loadedResolution = 'high';
                    highResImageCache.add(highResSrc);
                    imageLoadingStats.hits++;
                    
                    img.style.transition = 'opacity 0.3s ease';
                    img.style.opacity = '0.8';
                    setTimeout(() => {
                        img.style.opacity = '1';
                    }, 50);
                    
                    this.updateMatchingImages(originalSrc, highResProxyUrl);
                }
                
                this.removeLoadingState(item);
                this.totalProcessed = (this.totalProcessed || 0) + 1;
                this.updateProgressIndicator();
                return success;
            } catch (error) {
                imageLoadingStats.errors++;
                this.removeLoadingState(item);
                this.updateProgressIndicator();
                return false;
            }
        }

        updateMatchingImages(originalSrc, highResProxyUrl) {
            // Update any matching cards in the deck display
            updateDeckImagesWithHighRes(originalSrc, highResProxyUrl);
        }

        clear() {
            Object.values(this.priorityQueues).forEach(queue => queue.length = 0);
            this.activeLoads.clear();
            this.isProcessing = false;
            this.totalProcessed = 0;
            this.updateProgressIndicator();
        }

        addLoadingState(item, priority) {
            const container = item.container;
            if (!container) return;

            container.classList.remove('loading-queued', 'loading-priority', 'loading-deck');
            container.classList.add('loading-queued');
            
            if (priority === 'deck') {
                container.classList.add('loading-deck');
            } else if (priority === 'visible') {
                container.classList.add('loading-priority');
            }
        }

        removeLoadingState(item) {
            const container = item.container;
            if (!container) return;

            container.classList.remove('loading-queued', 'loading-priority', 'loading-deck', 'loading-high-res');
        }

        updateProgressIndicator() {
            // Only show progress indicator if user preference allows it and there are significant loads
            if (!userPrefs.get('enableProgressIndicator')) {
                return;
            }

            const totalQueued = Object.values(this.priorityQueues).reduce((sum, queue) => sum + queue.length, 0);
            const totalActive = this.activeLoads.size;
            const total = totalQueued + totalActive;
            
            const progressElement = document.getElementById('batch-progress');
            const textElement = document.getElementById('batch-progress-text');
            const fillElement = document.getElementById('batch-progress-fill');
            
            if (!progressElement) return;

            // Only show if there are more than 5 items loading (avoid showing for small batches)
            if (total > 5) {
                progressElement.classList.add('visible');
                
                const completed = Math.max(0, this.totalProcessed - totalQueued);
                const progress = total > 0 ? (completed / (completed + total)) * 100 : 0;
                
                textElement.textContent = `${total} images`;
                fillElement.style.width = `${Math.min(progress, 100)}%`;
            } else {
                progressElement.classList.remove('visible');
            }
        }

        getStats() {
            return {
                maxConcurrent: this.maxConcurrent,
                activeLoads: this.activeLoads.size,
                deckQueue: this.priorityQueues.deck.length,
                visibleQueue: this.priorityQueues.visible.length,
                backgroundQueue: this.priorityQueues.background.length,
                totalQueued: Object.values(this.priorityQueues).reduce((sum, queue) => sum + queue.length, 0),
                isProcessing: this.isProcessing,
                totalProcessed: this.totalProcessed || 0
            };
        }
    }

    // User preferences manager
    class UserPreferencesManager {
        constructor() {
            this.prefsKey = 'pokemon_tcg_user_prefs_v1';
            this.defaults = {
                highResEnabled: true,
                autoLoadHighRes: false, // Changed to false - only load on hover
                batchSize: 3,
                loadingDelay: 300,
                enableProgressIndicator: false
            };
            this.prefs = this.loadPreferences();
        }

        loadPreferences() {
            try {
                const stored = localStorage.getItem(this.prefsKey);
                return stored ? { ...this.defaults, ...JSON.parse(stored) } : this.defaults;
            } catch (error) {
                return this.defaults;
            }
        }

        savePreferences() {
            try {
                localStorage.setItem(this.prefsKey, JSON.stringify(this.prefs));
            } catch (error) {
            }
        }

        get(key) {
            return this.prefs[key] !== undefined ? this.prefs[key] : this.defaults[key];
        }

        set(key, value) {
            this.prefs[key] = value;
            this.savePreferences();
            this.applyPreferences();
        }

        applyPreferences() {
            // Apply batch loading preferences
            if (batchLoadManager) {
                batchLoadManager.maxConcurrent = this.get('batchSize');
                batchLoadManager.batchDelay = this.get('loadingDelay');
            }

            // Apply progress indicator preference
            const progressElement = document.getElementById('batch-progress');
            if (progressElement) {
                progressElement.style.display = this.get('enableProgressIndicator') ? 'block' : 'none';
            }
        }

        getAll() {
            return { ...this.prefs };
        }

        reset() {
            this.prefs = { ...this.defaults };
            this.savePreferences();
            this.applyPreferences();
        }
    }

    let highResImageCache = new ImageCacheManager();
    let batchLoadManager = new BatchLoadManager();
    let userPrefs = new UserPreferencesManager();
    let highResLoadTimeout = null;
    let progressiveLoadQueue = new Map(); // Track progressive loading tasks
    let imageLoadingStats = { hits: 0, misses: 0, errors: 0 }; // Performance tracking
    let activeRequests = new Map(); // Track active image requests to prevent duplicates
    let batchLoadQueue = new Set(); // Queue for batch loading (legacy)
    let batchLoadTimer = null; // Timer for batch processing (legacy)

    let currentSortType = 'set'; 
    let currentSortDirection = 'asc'; 
    let orderedSetNamesForSort = [];

    // Function to set sort type from URL parameters
    function setSortTypeFromURL() {
        const urlParams = new URLSearchParams(window.location.search);
        const sortParam = urlParams.get('sort');
        const directionParam = urlParams.get('direction');
        
        if (sortParam && ['set', 'rarity', 'type', 'name'].includes(sortParam)) {
            currentSortType = sortParam;
        }
        
        if (directionParam && ['asc', 'desc'].includes(directionParam)) {
            currentSortDirection = directionParam;
            sortTypeDirections[currentSortType] = directionParam;
        }
        
    } 
    let sortTypeDirections = {
        'set': 'asc',  
        'rarity': 'asc',  
        'type': 'asc',    
        'name': 'asc'     
    };

    let canShowDeckFullToast = true;
    let deckFullToastTimeoutId = null;       
    let deckFullToastCooldownTimeoutId = null; 
    let selectedDeckEnergies = [];
    let selectedFilterEnergies = [];
    let deckWasRestored = false;

    const DECK_FULL_TOAST_DURATION = 2500;   
    const DECK_FULL_TOAST_COOLDOWN = 2500; 

    const PENDING_DECK_KEY = 'pendingDeckToSave_v1';
    const ACTION_AFTER_AUTH_KEY = 'actionAfterAuth_v1';

    const rarityOrder = {
        // Lower number = higher rarity for default DESC sort
        'Crown Rare': 0, '✵✵': 1, '✵': 2,
        '☆☆☆': 3, '☆☆': 4, '☆': 5,
        '◊◊◊◊': 6, '◊◊◊': 7, '◊◊': 8, '◊': 9,
        'default': 99 // Handle null/undefined/unknown rarities
    };
    const typeOrder = {
        // Lower number = appears first for default ASC sort (A-Z like for types)
        'Grass': 0, 
        'Fire': 1, 
        'Water': 2, 
        'Lightning': 3, 
        'Psychic': 4,
        'Fighting': 5, 
        'Darkness': 6, 
        'Metal': 7, 
        'Dragon': 8, 
        'Colorless': 9,
        'Trainer': 10, // Trainers after all Pokémon energy types
        'default': 99  // For any other types or null/undefined card.energy_type
    };
    const stageOrder = {
        // Lower number means higher stage priority for sorting (e.g., Stage 2 appears before Stage 1)
        'Stage 2': 0,
        'Stage 1': 1,
        'Basic': 2,
        // For non-Pokemon (like Trainers, which will be grouped by 'Trainer' type first)
        // or Pokémon cards with unknown/unspecified stages.
        'Item': 3,      // Optional: if you want specific trainer subtypes ordered
        'Supporter': 4, // Optional
        'Tool': 5,      // Optional
        'Ultra Beast': 6,   // Optional (if you add this type)
        'default': 99 
    };

    document.addEventListener('DOMContentLoaded', function() {
        
        // Apply user preferences
        userPrefs.applyPreferences();
        
        // Register Service Worker for persistent caching
        registerServiceWorker();
        
        // Clean up expired auto-save data on page load
        cleanupExpiredAutoSaves();
        
        loadCards();
        setupEventListeners();
        initializeCardObserver();
        setupMobileImageLoading();
    });

    function initializeCardObserver() {
        if (!('IntersectionObserver' in window)) {
            return;
        }

        const cardCollectionEl = document.getElementById('card-collection');
        if (!cardCollectionEl) return;

        const options = {
            root: cardCollectionEl,
            rootMargin: '0px 0px 400px 0px', // Load images 400px below the viewport
            threshold: 0.01
        };

        cardObserver = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const cardItem = entry.target;
                    
                    // This is the one-line fix:
                    // We now find the container by a class that is always present.
                    const cardContainer = cardItem.querySelector('.position-relative');
                    const img = cardItem.querySelector('img[data-src]');

                    if (img && cardContainer) {
                        const originalSrc = img.getAttribute('data-src');
                        
                        // Check if high-res version is already cached from previous hover
                        const highResSrc = getHighResUrl(originalSrc);
                        let imageToLoad = originalSrc;
                        let isHighRes = false;
                        
                        // ONLY use cached high-res if it exists - never trigger new loads
                        if (userPrefs.get('highResEnabled') && highResImageCache.has(highResSrc)) {
                            imageToLoad = highResSrc;
                            isHighRes = true;
                        }
                        
                        const proxyUrl = getImageUrl(imageToLoad);

                        img.onload = () => {
                            // Ensure shimmer is visible for at least 200ms
                            setTimeout(() => {
                                cardContainer.classList.remove('is-loading');
                                cardContainer.classList.add('is-loaded');
                            }, 200);
                            
                            // Mark as high-res if we loaded the cached high-res version
                            if (isHighRes) {
                                img.dataset.loadedResolution = 'high';
                            }
                            
                            // NO automatic progressive loading - only load high-res on hover
                        };
                        img.onerror = () => {
                            cardContainer.classList.remove('is-loading');
                        };

                        img.src = proxyUrl;
                        img.removeAttribute('data-src');
                        // Keep original src for mobile high-res loading
                        if (!img.dataset.originalSrc) {
                            img.dataset.originalSrc = originalSrc;
                        }
                    }
                    observer.unobserve(cardItem);
                }
            });
        }, options);
    }

    // Image optimization helper functions

    function startProgressiveHighResLoading(img, originalSrc, cardContainer) {
        // This function is now ONLY called from hover events, not automatically
        // Check user preferences
        if (!userPrefs.get('highResEnabled')) {
            return;
        }

        // Skip if already loading or loaded high-res
        if (progressiveLoadQueue.has(originalSrc) || img.dataset.loadedResolution === 'high') {
            return;
        }

        // Check if high-res version exists
        if (!originalSrc.includes('/cards/')) {
            return;
        }

        const highResSrc = getHighResUrl(originalSrc);
        if (!highResSrc) {
            return; // No high-res available
        }
        const highResProxyUrl = highResSrc;

        // Add to progressive load queue (legacy compatibility)
        progressiveLoadQueue.set(originalSrc, {
            img: img,
            container: cardContainer,
            highResSrc: highResSrc,
            status: 'queued'
        });

        // Determine priority based on card location
        let priority = 'background';
        
        // Check if this is a deck card (higher priority)
        if (cardContainer?.closest('#current-deck')) {
            priority = 'deck';
        } 
        // Check if this card is currently visible in the viewport
        else if (isElementVisible(cardContainer)) {
            priority = 'visible';
        }

        // Use the new batch loading manager
        const loadItem = {
            img,
            originalSrc,
            highResSrc,
            highResProxyUrl,
            container: cardContainer
        };

        batchLoadManager.addToPriorityQueue(loadItem, priority);
    }

    // Helper function to check if element is visible in viewport
    function isElementVisible(element) {
        if (!element) return false;
        
        const rect = element.getBoundingClientRect();
        const windowHeight = window.innerHeight || document.documentElement.clientHeight;
        const windowWidth = window.innerWidth || document.documentElement.clientWidth;
        
        return (
            rect.top < windowHeight &&
            rect.bottom > 0 &&
            rect.left < windowWidth &&
            rect.right > 0
        );
    }

    function loadHighResImage(img, highResSrc, highResProxyUrl, originalSrc) {
        const queueItem = progressiveLoadQueue.get(originalSrc);
        if (!queueItem || queueItem.status !== 'queued') {
            return;
        }

        queueItem.status = 'loading';

        // Check if already in cache
        if (highResImageCache.has(highResSrc)) {
            img.src = highResProxyUrl;
            img.dataset.loadedResolution = 'high';
            progressiveLoadQueue.delete(originalSrc);
            imageLoadingStats.hits++;
            
            // Update any matching cards in the deck display
            updateDeckImagesWithHighRes(originalSrc, highResProxyUrl);
            return;
        }

        // Use deduplicated request
        loadImageWithDeduplication(highResProxyUrl, highResSrc).then((success) => {
            if (success && img.parentElement && !img.dataset.replacedByHover) {
                img.src = highResProxyUrl;
                img.dataset.loadedResolution = 'high';
                highResImageCache.add(highResSrc);
                imageLoadingStats.hits++;
                
                // Add subtle transition effect
                img.style.transition = 'opacity 0.3s ease';
                img.style.opacity = '0.8';
                setTimeout(() => {
                    img.style.opacity = '1';
                }, 50);
                
                // Update any matching cards in the deck display
                updateDeckImagesWithHighRes(originalSrc, highResProxyUrl);
            }
            progressiveLoadQueue.delete(originalSrc);
        });
    }

    // Request deduplication to prevent multiple requests for the same image
    function loadImageWithDeduplication(proxyUrl, originalSrc) {
        return new Promise((resolve) => {
            // Check if request is already in progress
            if (activeRequests.has(originalSrc)) {
                // Add to existing request's callback list
                activeRequests.get(originalSrc).callbacks.push(resolve);
                return;
            }

            // Create new request
            const requestInfo = {
                callbacks: [resolve],
                image: new Image()
            };

            activeRequests.set(originalSrc, requestInfo);

            requestInfo.image.onload = () => {
                // Notify all callbacks
                requestInfo.callbacks.forEach(callback => callback(true));
                activeRequests.delete(originalSrc);
                imageLoadingStats.misses++;
            };

            requestInfo.image.onerror = () => {
                requestInfo.callbacks.forEach(callback => callback(false));
                activeRequests.delete(originalSrc);
                imageLoadingStats.errors++;
            };

            requestInfo.image.src = proxyUrl;
        });
    }

    // Batch loading system for efficient network usage
    function addToBatchLoadQueue(originalSrc, priority = 'normal') {
        batchLoadQueue.add({
            src: originalSrc,
            priority: priority,
            timestamp: Date.now()
        });

        // Schedule batch processing
        if (batchLoadTimer) {
            clearTimeout(batchLoadTimer);
        }

        batchLoadTimer = setTimeout(processBatchLoad, 100); // Process batch every 100ms
    }

    function processBatchLoad() {
        if (batchLoadQueue.size === 0) return;

        const batch = Array.from(batchLoadQueue)
            .sort((a, b) => {
                // Sort by priority (high first), then by timestamp (older first)
                const priorityOrder = { high: 0, normal: 1, low: 2 };
                const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];
                if (priorityDiff !== 0) return priorityDiff;
                return a.timestamp - b.timestamp;
            })
            .slice(0, 5); // Process up to 5 images at once

        batchLoadQueue.clear();

        // Process the batch
        batch.forEach(item => {
            const proxyUrl = getImageUrl(item.src);
            loadImageWithDeduplication(proxyUrl, item.src);
        });
    }

    // Enhanced caching with size limits and intelligent eviction
    function manageImageCache() {
        // Cache management is now handled automatically by ImageCacheManager
        // This function is kept for compatibility but delegates to the cache manager
        highResImageCache.manageSize();
    }

    // Service Worker registration for persistent caching
    function registerServiceWorker() {
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/static/js/image-cache-sw.js')
                .then(registration => {
                })
                .catch(error => {
                });
        }
    }

    // Performance monitoring and metrics
    function getImageLoadingStats() {
        const cacheStats = highResImageCache.getStats();
        const batchStats = batchLoadManager.getStats();
        return {
            ...imageLoadingStats,
            ...cacheStats,
            ...batchStats,
            cacheSize: highResImageCache.size,
            queueSize: progressiveLoadQueue.size,
            activeRequests: activeRequests.size,
            batchQueueSize: batchLoadQueue.size, // Legacy
            progressiveLoadingActive: progressiveLoadQueue.size > 0,
            cacheHitRate: imageLoadingStats.hits / (imageLoadingStats.hits + imageLoadingStats.misses) || 0,
            errorRate: imageLoadingStats.errors / (imageLoadingStats.hits + imageLoadingStats.misses + imageLoadingStats.errors) || 0
        };
    }

    // Performance monitoring console command
    window.getImagePerformanceStats = function() {
        const stats = getImageLoadingStats();
        return stats;
    };

    // Cache management console commands
    window.clearImageCache = function() {
        highResImageCache.clear();
        batchLoadManager.clear();
    };

    window.getCacheStats = function() {
        return highResImageCache.getStats();
    };

    window.getBatchStats = function() {
        return batchLoadManager.getStats();
    };

    window.adjustBatchSettings = function(maxConcurrent = 3, batchDelay = 300) {
        userPrefs.set('batchSize', maxConcurrent);
        userPrefs.set('loadingDelay', batchDelay);
    };

    // User preference console commands
    window.getUserPrefs = function() {
        const prefs = userPrefs.getAll();
        Object.entries(prefs).forEach(([key, value]) => {
        });
        return prefs;
    };

    window.setUserPref = function(key, value) {
        userPrefs.set(key, value);
    };

    window.resetUserPrefs = function() {
        userPrefs.reset();
    };

    window.toggleHighRes = function() {
        const current = userPrefs.get('highResEnabled');
        userPrefs.set('highResEnabled', !current);
    };

    window.toggleAutoLoad = function() {
        const current = userPrefs.get('autoLoadHighRes');
        userPrefs.set('autoLoadHighRes', !current);
    };

    // Automatic performance monitoring every 30 seconds
    setInterval(() => {
        const stats = getImageLoadingStats();
        if (stats.errorRate > 0.1) { // More than 10% error rate
        }
        
        // Manage cache size
        manageImageCache();
    }, 30000);

    // Mobile high-res loading on tap
    let isTouchDevice = false;

    function setupMobileImageLoading() {
        // Check if this is a touch device
        isTouchDevice = window.matchMedia("(hover: none)").matches || 'ontouchstart' in window;
        
        if (!isTouchDevice) {
            return;
        }
        
    }

    function loadHighResForMobile(img) {
        const originalSrc = img.dataset.originalSrc || img.getAttribute('data-original-src') || img.src;
        
        if (!originalSrc || !originalSrc.includes('/cards/') || img.dataset.loadedResolution === 'high') {
            return;
        }
        
        const highResSrc = getHighResUrl(originalSrc);
        if (!highResSrc) {
            return; // No high-res available
        }
        const highResProxyUrl = highResSrc;
        
        // Check if already in cache
        if (highResImageCache.has(highResSrc)) {
            img.src = highResProxyUrl;
            img.dataset.loadedResolution = 'high';
            
            // Update any matching cards in the deck display
            updateDeckImagesWithHighRes(originalSrc, highResProxyUrl);
            return;
        }
        
        // Load with deduplication (no visual indicators)
        loadImageWithDeduplication(highResProxyUrl, highResSrc).then((success) => {
            if (success && img.parentElement) {
                img.src = highResProxyUrl;
                img.dataset.loadedResolution = 'high';
                highResImageCache.add(highResSrc);
                
                // Update any matching cards in the deck display
                updateDeckImagesWithHighRes(originalSrc, highResProxyUrl);
            }
        });
    }

    function updateDeckImagesWithHighRes(originalSrc, highResProxyUrl) {
        // Find all deck slot images that match the original source
        const deckContainer = document.getElementById('current-deck');
        if (!deckContainer) return;
        
        const deckImages = deckContainer.querySelectorAll('img[data-original-src]');
        deckImages.forEach(deckImg => {
            if (deckImg.dataset.originalSrc === originalSrc && deckImg.dataset.loadedResolution !== 'high') {
                deckImg.src = highResProxyUrl;
                deckImg.dataset.loadedResolution = 'high';
            }
        });
    }

    // Initialize filters data on first load
    async function initializeFiltersData() {
        try {
            // Fetch first page just to get set data for dropdowns
            const response = await fetch('/api/cards/paginated?page=1&limit=100');
            const data = await response.json();
            
            if (data && data.cards && data.cards.length > 0) {
                const uniqueSetsData = [];
                const encounteredSetCodes = new Set();

                data.cards.forEach(card => {
                    if (card.set_name && card.set_name.trim() !== "" && card.set_code && card.set_code.trim() !== "") {
                        const setName = card.set_name.trim();
                        const setCode = card.set_code.trim();
                        if (!encounteredSetCodes.has(setCode)) {
                            encounteredSetCodes.add(setCode);
                            uniqueSetsData.push({ name: setName, code: setCode });
                        }
                    }
                });

                function parseSetCode(code) {
                    const promoMatch = code.match(/^P[A-Z]*-([A-Z0-9]+(?:[a-z]?))$/i) || code.match(/^P-([A-Z0-9]+(?:[a-z]?))$/i) || code.match(/^P([A-Z0-9]+(?:[a-z]?))$/i);
                    if (promoMatch) {
                        return { isPromo: true, prefix: "P", suffix: promoMatch[1] || code, original: code };
                    }
                    const match = code.match(/^([A-Z]+)([0-9A-Za-z].*)$/);
                    if (match) {
                        return { isPromo: false, prefix: match[1], suffix: match[2], original: code };
                    }
                    return { isPromo: false, prefix: "", suffix: code, original: code };
                }

                uniqueSetsData.sort((a, b) => {
                    const parsedA = parseSetCode(a.code);
                    const parsedB = parseSetCode(b.code);
                    if (parsedA.isPromo && !parsedB.isPromo) return 1;
                    if (!parsedA.isPromo && parsedB.isPromo) return -1;
                    if (parsedA.isPromo && parsedB.isPromo) {
                        return parsedA.original.localeCompare(parsedB.original);
                    }
                    if (parsedA.prefix > parsedB.prefix) return -1;
                    if (parsedA.prefix < parsedB.prefix) return 1;
                    if (parsedA.suffix > parsedB.suffix) return -1;
                    if (parsedA.suffix < parsedB.suffix) return 1;
                    return 0;
                });
                
                orderedSetNamesForSort = uniqueSetsData.map(setObj => setObj.name);
                populateDropdown('set-dropdown', ['All', ...orderedSetNamesForSort]);
                const setBtn = document.getElementById('setDropdown');
                if (setBtn && setBtn.querySelector('.btn-text')) {
                    setBtn.querySelector('.btn-text').textContent = 'All';
                }
            }
        } catch (error) {
        }
    }

    function showCardSkeletons(count = 12) {
        const cardCollectionDiv = document.getElementById('card-collection');
        if (!cardCollectionDiv) return;
        
        let skeletonsHTML = '<div class="row g-2">';
        for (let i = 0; i < count; i++) {
            skeletonsHTML += `
                <div class="col-4 col-sm-4 col-md-4 col-lg-3 col-xl-2 mb-3 card-item">
                    <div class="position-relative clickable-card is-loading">
                    </div>
                </div>
            `;
        }
        skeletonsHTML += '</div>';
        
        cardCollectionDiv.innerHTML = skeletonsHTML;
    }

    // New paginated card loading function
    async function loadCardsPage(page = 1, append = false, isInitialLoad = false) {
        if (isLoading) return;
        
        isLoading = true;
        const cardCollectionDiv = document.getElementById('card-collection');
        
        try {
            if (!append) {
                if (cardCollectionDiv) {
                    // Only show skeleton cards if not initial load (HTML already has them)
                    if (!isInitialLoad) {
                        showCardSkeletons(12);
                    }
                }
                loadedIds.clear();
                filteredCards = [];
            }

            // Build query parameters
            const params = new URLSearchParams({
                page: page.toString(),
                limit: '24' // Load 24 cards per page for good performance
            });

            // Add filters to query
            if (selectedFilters.cardType !== 'All') {
                params.append('card_type', selectedFilters.cardType);
            }
            if (selectedFilters.stageType !== 'All') {
                params.append('stage_type', selectedFilters.stageType);
            }
            if (selectedFilters.rarity !== 'All') {
                params.append('rarity', selectedFilters.rarity);
            }
            if (selectedFilters.set !== 'All') {
                // Convert set name to set code for the API
                const setData = orderedSetNamesForSort?.find(name => name === selectedFilters.set);
                if (setData) {
                    params.append('set_code', setData);
                }
            }
            // Combine search text with energy type keywords
            const searchComponents = [];
            if (rawSearchText.trim()) {
                searchComponents.push(rawSearchText.trim());
            }
            if (selectedFilters.energyTypes.length > 0) {
                // Convert energy types to keywords for multi-type filtering
                const energyTypeMapping = {
                    'Grass': 'grass',
                    'Fire': 'fire', 
                    'Water': 'water',
                    'Lightning': 'lightning',
                    'Psychic': 'psychic',
                    'Fighting': 'fighting',
                    'Darkness': 'darkness',
                    'Metal': 'metal',
                    'Dragon': 'dragon',
                    'Colorless': 'colorless'
                };
                const energyKeywords = selectedFilters.energyTypes.map(type => energyTypeMapping[type] || type.toLowerCase());
                searchComponents.push(...energyKeywords);
            }
            if (searchComponents.length > 0) {
                params.append('name', searchComponents.join(' '));
            }
            
            // Add sorting parameters
            if (currentSortType) {
                params.append('sort', currentSortType);
            }
            if (currentSortDirection) {
                params.append('direction', currentSortDirection);
            }


            const response = await fetch(`/api/cards/paginated?${params}`);
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }

            const data = await response.json();
            
            if (data.success && data.cards) {
                
                // Filter out duplicates
                const newCards = data.cards.filter(card => !loadedIds.has(card.id));
                newCards.forEach(card => loadedIds.add(card.id));
                
                if (append) {
                    filteredCards.push(...newCards);
                } else {
                    filteredCards = newCards;
                }
                // Note: allCards is loaded separately with ALL cards for deck building

                hasMoreCards = data.pagination.has_more;
                currentPage = page;

                
                if (typeof updateCardDisplay === 'function') {
                    updateCardDisplay(append, isInitialLoad);
                } else {
                }
                
                
                const count = data.pagination.total_count || filteredCards.length;
                const cardText = (count === 1) ? 'card' : 'cards';
                document.getElementById('card-count-search').textContent = `${count} ${cardText}`;

                // Set up infinite scroll if we have more cards
                if (hasMoreCards && !append) {
                    setupInfiniteScroll();
                }

                // IMPORTANT: Force load images for newly added cards
                setTimeout(() => {
                    const cardCollection = document.getElementById('card-collection');
                    if (!cardCollection) return;
                    
                    const newCardItems = cardCollection.querySelectorAll('.card-item');
                    newCardItems.forEach(cardItem => {
                        const img = cardItem.querySelector('img[data-src]');
                        if (img && img.dataset.src && !img.src) {
                            // Force load the image immediately for now
                            img.src = img.dataset.src;
                            img.removeAttribute('data-src');
                            
                            // Also observe with intersection observer if available
                            if (cardObserver) {
                                cardObserver.observe(cardItem);
                            }
                        }
                    });
                }, 100);
            } else {
                if (!append) {
                    filteredCards = [];
                    if (cardCollectionDiv) {
                        cardCollectionDiv.innerHTML = '<div class="text-center p-3"><p>No cards found.</p></div>';
                    }
                }
                hasMoreCards = false;
            }

        } catch (error) {
            if (!append && cardCollectionDiv) {
                cardCollectionDiv.innerHTML = '';
            }
            hasMoreCards = false;
        } finally {
            isLoading = false;
            hideSearchInputSpinner();
        }
    }

    // Set up infinite scroll
    function setupInfiniteScroll() {
        const cardCollectionDiv = document.getElementById('card-collection');
        if (!cardCollectionDiv) return;

        // Create or get the scroll sentinel
        let sentinel = cardCollectionDiv.querySelector('.scroll-sentinel');
        if (!sentinel) {
            sentinel = document.createElement('div');
            sentinel.className = 'scroll-sentinel';
            sentinel.style.height = '20px';
            sentinel.style.margin = '20px 0';
            cardCollectionDiv.appendChild(sentinel);
        }

        // Set up intersection observer for infinite scroll
        if (window.scrollObserver) {
            window.scrollObserver.disconnect();
        }

        window.scrollObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && hasMoreCards && !isLoading) {
                    loadCardsPage(currentPage + 1, true);
                }
            });
        }, {
            rootMargin: '100px'
        });

        window.scrollObserver.observe(sentinel);
    }

    // Load ALL cards for deck building, then load first page for display
    async function loadCards() {
        
        // First load ALL cards for deck building
        try {
            const response = await fetch('/api/cards');
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            const data = await response.json();
            if (data && data.cards && data.cards.length > 0) {
                allCards = data.cards;
            } else {
                allCards = [];
            }
        } catch (error) {
            allCards = [];
        }
        
        // Then initialize filters and load first page for display
        
        try {
            await initializeFiltersData();
            
            await loadCardsPage(1, false, true);
            
            // Code after loading
            // Handle deck restoration after cards are loaded
            let restoredPendingDeck = false;
            let userIsAuthenticated = window.IS_USER_AUTHENTICATED || false;

            if (userIsAuthenticated) {
                const actionAfterAuth = sessionStorage.getItem('ACTION_AFTER_AUTH_KEY');
                if (actionAfterAuth === 'savePendingDeck') {
                    const pendingDeckJSON = sessionStorage.getItem(PENDING_DECK_KEY);
                    if (pendingDeckJSON) {
                        sessionStorage.removeItem(PENDING_DECK_KEY);
                        sessionStorage.removeItem(ACTION_AFTER_AUTH_KEY);
                        try {
                            const pendingDeck = JSON.parse(pendingDeckJSON);
                            document.getElementById('deck-name').value = pendingDeck.name || '';
                            // Note: For pending deck restoration, we might need to fetch specific cards
                            // This is a limitation of the new paginated approach
                            selectedDeckEnergies = pendingDeck.deck_types || [];
                            coverCardIds = (pendingDeck.cover_card_ids || []).map(id => String(id));
                            loadedDeckId = null; 
                            deckSaved = false;
                            updateAllDeckUI();
                            restoredPendingDeck = true;
                        } catch (error) {
                        }
                    } else {
                        sessionStorage.removeItem(ACTION_AFTER_AUTH_KEY); 
                    }
                }
            }

            if (window.matchMedia("(hover: none)").matches) {
                // Enhanced mobile deck restoration with persistent storage
                const restoreDeckFromStorage = () => {
                    try {
                        let autoSavedDeck = null;
                        let storageSource = '';
                        
                        // Try session storage first (most recent)
                        const sessionData = sessionStorage.getItem('autoSavedDeck');
                        if (sessionData) {
                            autoSavedDeck = JSON.parse(sessionData);
                            storageSource = 'session';
                        }
                        
                        // Fall back to persistent storage if session is empty
                        if (!autoSavedDeck) {
                            const persistentData = localStorage.getItem('autoSavedDeck_persistent');
                            if (persistentData) {
                                const parsedData = JSON.parse(persistentData);
                                // Check if data is not too old (7 days max)
                                const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds
                                if (!parsedData.timestamp || (Date.now() - parsedData.timestamp) < maxAge) {
                                    autoSavedDeck = parsedData;
                                    storageSource = 'persistent';
                                } else {
                                    // Remove expired data
                                    localStorage.removeItem('autoSavedDeck_persistent');
                                }
                            }
                        }
                        
                        if (autoSavedDeck && autoSavedDeck.cards && autoSavedDeck.cards.length > 0) {
                            // Show restoration toast notification with source info
                            if (window.showGlobalToast) {
                                const message = storageSource === 'persistent' 
                                    ? "Restoring previous draft..." 
                                    : "Restoring unsaved changes...";
                                window.showGlobalToast(message, "default", 3000);
                            }
                            
                            // Restore deck metadata
                            document.getElementById('deck-name').value = autoSavedDeck.name || '';
                            selectedDeckEnergies = autoSavedDeck.deck_types || [];
                            coverCardIds = (autoSavedDeck.cover_card_ids || []).map(id => String(id));
                            loadedDeckId = null;
                            deckSaved = false;
                            
                            // Restore actual cards to currentDeck array
                            currentDeck = [];
                            let restoredCount = 0;
                            autoSavedDeck.cards.forEach(savedCard => {
                                const fullCardData = allCards.find(c => c.id === savedCard.id);
                                if (fullCardData) {
                                    currentDeck.push(fullCardData);
                                    restoredCount++;
                                }
                            });
                            
                            // Update all UI components after restoration
                            updateDeckDisplay();
                            updateEnergyCounter();
                            updateCoverCardDisplay();
                            
                            // Immediately update energy icons
                            updateDeckEnergyIconsVisualState();
                            
                            // Mobile-specific energy restoration with multiple attempts
                            if (window.matchMedia("(hover: none)").matches) {
                                // First attempt - immediate
                                updateDeckEnergyIconsVisualState();
                                
                                // Second attempt - after next frame
                                requestAnimationFrame(() => {
                                    updateDeckEnergyIconsVisualState();
                                    updateEnergyCounter();
                                    
                                    // Third attempt - after short delay for slower devices
                                    setTimeout(() => {
                                        // Find and manually update each energy icon
                                        document.querySelectorAll('.energy-selection-bar .energy-icon-wrapper.deck-energy').forEach(icon => {
                                            const energyType = icon.getAttribute('data-type');
                                            if (selectedDeckEnergies.includes(energyType)) {
                                                icon.classList.add('active');
                                                // Force inline style as fallback
                                                icon.style.opacity = '1';
                                                icon.style.transform = 'scale(1.15)';
                                            }
                                        });
                                        console.log('Mobile deck restoration complete - energy types:', selectedDeckEnergies);
                                    }, 250);
                                });
                            }
                            
                            // Log successful restoration for debugging
                            console.log(`Restored ${restoredCount} cards from ${storageSource} storage`);
                            
                            return true; // Successfully restored
                        }
                    } catch (error) {
                        console.warn('Failed to restore deck from storage:', error);
                        // Clean up corrupted data
                        sessionStorage.removeItem('autoSavedDeck');
                        localStorage.removeItem('autoSavedDeck_persistent');
                    }
                    return false;
                };
                
                // Attempt restoration if no pending deck was restored
                if (!restoredPendingDeck) {
                    restoreDeckFromStorage();
                }
            }

            if (!restoredPendingDeck) { 
                if (!userIsAuthenticated) {
                    clearDeck(false);
                }
            }

            const editDeckId = new URLSearchParams(window.location.search).get('edit');
            if (editDeckId) {
                loadDeckData(editDeckId, false);
            }

            setSortTypeFromURL();
            updateSortDropdownUI();
            
            // Initialize deck display if no deck was loaded
            if (!editDeckId && !restoredPendingDeck) {
                updateDeckDisplay();
            }
            
            // Ensure energy icons are properly displayed on mobile after everything is loaded
            if (window.matchMedia("(hover: none)").matches && selectedDeckEnergies.length > 0) {
                console.log('Applying mobile energy fix for energies:', selectedDeckEnergies);
                
                // Wait for images to load and DOM to settle
                setTimeout(() => {
                    const energyIcons = document.querySelectorAll('.energy-selection-bar .energy-icon-wrapper.deck-energy');
                    console.log('Found energy icons:', energyIcons.length);
                    
                    energyIcons.forEach(icon => {
                        const energyType = icon.getAttribute('data-type');
                        if (selectedDeckEnergies.includes(energyType)) {
                            icon.classList.add('active');
                            console.log(`Manually activated ${energyType} icon on mobile`);
                        }
                    });
                    
                    updateEnergyCounter();
                }, 500);
            }
            
            // Always ensure deck display is initialized for empty decks
            if (currentDeck.length === 0) {
                updateDeckDisplay();
            }
            
        } catch (error) {
            const cardCollectionDiv = document.getElementById('card-collection');
            if (cardCollectionDiv) {
                cardCollectionDiv.innerHTML = '';
            }
            clearDeck(false);
        }
    }

    function loadDeckData(deckIdToLoad, isCopyOperation) {
        
        fetch(`/api/decks/${deckIdToLoad}`) 
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status} fetching deck ID ${deckIdToLoad}`);
                }
                return response.json();
            })
            .then(data => { 
                if (!data.success || !data.deck) {
                    const errorMsg = data.error || 'Deck data not found or invalid server response.';
                    alert(`Failed to load deck data for '${deckIdToLoad}'. Error: ${errorMsg}. Starting with a new deck.`);
                    clearDeck(false); 
                    return;
                }

                const deckFromServer = data.deck;
                currentDeck = []; 
                if (deckFromServer.cards && Array.isArray(deckFromServer.cards)) {
                    deckFromServer.cards.forEach(cardInfoFromServer => {
                        const fullCardData = allCards.find(c => c.id === cardInfoFromServer.id); 
                        if (fullCardData) {
                            currentDeck.push(fullCardData);
                        }
                    });
                }

                selectedDeckEnergies = deckFromServer.deck_types || [];
                coverCardIds = (deckFromServer.cover_card_ids || []).map(id => String(id)); 

                if (isCopyOperation) {
                    document.getElementById('deck-name').value = `Copy of ${deckFromServer.name || 'Unnamed Deck'}`;
                    loadedDeckId = null;
                    deckSaved = false;
                } else {
                    document.getElementById('deck-name').value = deckFromServer.name || '';
                    loadedDeckId = deckFromServer.id;
                    deckSaved = true; 
                }
                
                // This call updates the entire UI after the data is loaded.
                updateAllDeckUI(); 
            })
            .catch(error => {
                alert(`Could not load data for deck '${deckIdToLoad}'. ${error.message}. Starting with a new deck.`);
                clearDeck(false);
            });
    }
    
    function updateAllDeckUI() {
        // 1. Update the deck list on the right and other UI elements
        updateDeckDisplay();
        setCoverCardStarVisuals();
        updateDeckEnergyIconsVisualState();
        updateEnergyCounter();


        // 3. Update all card visuals in the main collection view
        // This loops through every card element and calls your existing update function,
        // which correctly handles adding OR removing badges and styles.
        document.querySelectorAll('.card-item').forEach(cardElement => {
            const cardId = cardElement.dataset.cardId;
            if (cardId) {
                updateCardStateInCollection(cardId);
            }
        });
    }

    function updateDeckEnergyIconsVisualState() { // Example helper
        // Update all deck energy icons - use more specific selector
        const energyIcons = document.querySelectorAll('.energy-selection-bar .energy-icon-wrapper[data-type]');
        
        console.log('updateDeckEnergyIconsVisualState called:', {
            foundIcons: energyIcons.length,
            selectedEnergies: selectedDeckEnergies,
            isMobile: window.matchMedia("(hover: none)").matches
        });
        
        energyIcons.forEach(icon => {
            const energyType = icon.getAttribute('data-type');
            const wasActive = icon.classList.contains('active');
            
            if (selectedDeckEnergies.includes(energyType)) {
                icon.classList.add('active');
                // Also ensure parent has active class if it's a wrapper
                if (icon.classList.contains('deck-energy')) {
                    icon.classList.add('active');
                }
                if (!wasActive) {
                    console.log(`Added active class to ${energyType} icon`);
                }
            } else {
                icon.classList.remove('active');
                if (wasActive) {
                    console.log(`Removed active class from ${energyType} icon`);
                }
            }
        });
        
        // Force style recalculation on mobile with more aggressive approach
        if (window.matchMedia("(hover: none)").matches) {
            energyIcons.forEach(icon => {
                // Force reflow
                icon.style.display = 'none';
                icon.offsetHeight;
                icon.style.display = '';
                
                // Double-check active state visually
                if (icon.classList.contains('active')) {
                    // Ensure the styles are applied
                    const img = icon.querySelector('img');
                    if (img) {
                        img.style.opacity = '1';
                    }
                }
            });
        }
    }

    function updateDropdownDisplays() {
        // Card Type dropdown - just show the selected value without a label
        const cardTypeBtn = document.getElementById('cardTypeDropdown');
        if (cardTypeBtn && cardTypeBtn.querySelector('.btn-text')) {
            cardTypeBtn.querySelector('.btn-text').textContent = 
                selectedFilters.cardType === 'All' ? 'All' : selectedFilters.cardType;
        }

        // Stage/Trainer Type dropdown - just show the selected value without a label
        const stageTypeBtn = document.getElementById('stageTypeDropdown');
        if (stageTypeBtn && stageTypeBtn.querySelector('.btn-text')) {
            stageTypeBtn.querySelector('.btn-text').textContent = 
                selectedFilters.stageType === 'All' ? 'All' : selectedFilters.stageType;
        }

        // Rarity dropdown - just show the selected value without a label
        const rarityBtn = document.getElementById('rarityDropdown');
        if (rarityBtn && rarityBtn.querySelector('.btn-text')) {
            rarityBtn.querySelector('.btn-text').textContent = 
                selectedFilters.rarity === 'All' ? 'All' : selectedFilters.rarity;
        }

        // Set dropdown - just show the selected value without a label
        const setBtn = document.getElementById('setDropdown');
        if (setBtn && setBtn.querySelector('.btn-text')) {
            setBtn.querySelector('.btn-text').textContent = 
                selectedFilters.set === 'All' ? 'All' : selectedFilters.set;
        }
    }

    function loadExistingDeck(filename) {

        // Optional: Show loading indicator
        // const deckContainer = document.getElementById('current-deck');
        // if(deckContainer) deckContainer.innerHTML = '<div class="text-center p-3"><span class="spinner-border spinner-border-sm"></span> Loading deck...</div>';

        fetch(`/api/decks/${filename}`) // Ensure this route exists and returns JSON
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                document.getElementById('deck-name').value = data.name;

                // Clear current state before loading
                currentDeck = [];
                selectedDeckEnergies = []; // Assuming you also have this array
                coverCardIds = null; // Reset cover card ID before loading from data
                document.querySelectorAll('.energy-selection-bar .energy-icon-wrapper.active').forEach(icon => icon.classList.remove('active'));

                // Load cards into the deck
                if (data.cards && Array.isArray(data.cards)) {
                    data.cards.forEach(deckCardInfo => {
                        // Find the full card details from the master 'allCards' list
                        const fullCard = allCards.find(c => c.id === deckCardInfo.id);
                        if (fullCard) {
                            currentDeck.push(fullCard);
                        } else {
                            // Optionally, add placeholder or skip
                        }
                    });
                } else {
                }

            // Load deck energy types
                if (data.deck_types && Array.isArray(data.deck_types)) {
                    selectedDeckEnergies = [...data.deck_types]; // Use new array
                    document.querySelectorAll('.energy-selection-bar .energy-icon-wrapper').forEach(icon => {
                        const energyType = icon.getAttribute('data-type');
                        if (selectedDeckEnergies.includes(energyType)) {
                            icon.classList.add('active');
                        }
                    });
                } else {
                    selectedDeckEnergies = []; // Ensure it's an empty array if missing
                }

                // Load cover card ID from saved data
                coverCardIds = data.cover_card_ids || null; // Use null if missing or explicitly null
                // Note: If cover_card_ids is null, the backend's default logic likely sets one when saving/displaying if needed.

                // Update displays (updateDeckDisplay will now use coverCardIds to set the star correctly)
                updateDeckDisplay();
                updateCardDisplay(); // Refresh collection view (grey out added cards)
                updateEnergyCounter();
                deckSaved = true; // Mark as saved after loading
            })
            .catch(error => {
                alert(`Failed to load deck '${filename}'. ${error.message}. Please check the console and try again.`);
                // Optional: Clear the possibly partial loading indicator
                // if(deckContainer) deckContainer.innerHTML = '<div class="alert alert-danger">Failed to load deck.</div>';
            });
    }

    function populateDropdown(dropdownId, options) {
        const dropdown = document.getElementById(dropdownId);
        if (!dropdown) {
            return;
        }
        dropdown.innerHTML = ''; // Clear existing items

        options.forEach((option, index) => {
            const li = document.createElement('li');
            const link = document.createElement('a');
            link.className = 'dropdown-item';
            if (index === 0) { // First item ("All") is active by default
                link.classList.add('active');
            }
            link.href = '#';
            link.dataset.value = option;

            // Keep special handling for Crown Rare emoji in Rarity dropdown
            if (option === 'Crown Rare' && dropdownId === 'rarity-dropdown') {
                link.innerHTML = '👑';
                // link.dataset.value remains 'Crown Rare'
            } else {
                link.textContent = option;
            }
            li.appendChild(link);
            dropdown.appendChild(li);
        });
    }
    function forceReflow(element) {
        if (!element) return;
        // Reading offsetHeight is a common way to trigger reflow
        void element.offsetHeight;
    }

    function setupDropdownListeners() {
        const dropdownConfig = {
            'card-type-dropdown': { property: 'cardType', labelId: 'cardTypeDropdown' },
            'stage-type-dropdown': { property: 'stageType', labelId: 'stageTypeDropdown' },
            'rarity-dropdown': { property: 'rarity', labelId: 'rarityDropdown' },
            'set-dropdown': { property: 'set', labelId: 'setDropdown' } // Ensure this is here
        };

        Object.entries(dropdownConfig).forEach(([dropdownId, config]) => {
            const dropdown = document.getElementById(dropdownId);
            if (!dropdown) return;

            dropdown.addEventListener('click', function(e) {
                if (e.target.tagName === 'A' && e.target.classList.contains('dropdown-item')) {
                    e.preventDefault();
                    const selectedValue = e.target.dataset.value;
                    selectedFilters[config.property] = selectedValue;
                    resetAddCardsScroll();

                    // --- START: New Logic to Reset Energy Filters ---
                    if (config.property === 'stageType' && 
                        ['Item', 'Supporter', 'Tool'].includes(selectedValue)) {
                        
                        selectedFilters.energyTypes = []; // Clear the internal array

                        // Deactivate all energy filter icons visually
                        // This will also be handled by applyFilters() if it correctly updates
                        // the UI based on selectedFilters.energyTypes, but doing it here explicitly
                        // can be good for immediate UI feedback if applyFilters() is complex.
                        // However, if applyFilters() reliably updates the energy icon UI from selectedFilters.energyTypes,
                        // just clearing the array above is sufficient before calling applyFilters().
                        document.querySelectorAll('.filter-bar .energy-icons .energy-icon-wrapper.active').forEach(activeIcon => {
                            activeIcon.classList.remove('active');
                        });
                    }

                    this.querySelectorAll('a.dropdown-item.active').forEach(activeA => activeA.classList.remove('active'));
                    e.target.classList.add('active');

                    const button = document.getElementById(config.labelId);
                    if (button && button.querySelector('.btn-text')) {
                        const btnText = button.querySelector('.btn-text');
                        // Use textContent for most, but handle emoji for Crown Rare
                        if (selectedValue === 'Crown Rare' && config.property === 'rarity') {
                            btnText.textContent = e.target.innerHTML; // To get the emoji
                        } else {
                            btnText.textContent = e.target.textContent;
                        }
                    }
                    applyFilters();
                    
                    // Hide dropdown and remove hover state like sort dropdown
                    if (button && typeof bootstrap !== 'undefined' && bootstrap.Dropdown) {
                        const bsDropdownInstance = bootstrap.Dropdown.getInstance(button);
                        if (bsDropdownInstance) {
                            bsDropdownInstance.hide();
                        }
                    }
                }
            });
        });
    }

    function parseSearchKeywords(searchText) {
        // Define keyword mappings (matching backend logic)
        const energyTypeKeywords = {
            'grass': 'Grass', 'fire': 'Fire', 'water': 'Water',
            'lightning': 'Lightning', 'electric': 'Lightning', 'psychic': 'Psychic',
            'fighting': 'Fighting', 'darkness': 'Darkness', 'dark': 'Darkness',
            'metal': 'Metal', 'steel': 'Metal', 'dragon': 'Dragon',
            'colorless': 'Colorless', 'normal': 'Colorless'
        };
        
        const cardTypeKeywords = {
            'trainer': 'Trainer', 'pokémon': 'Pokémon', 'pokemon': 'Pokémon'
        };
        
        const singleWordStageKeywords = {
            'item': 'Item', 'tool': 'Tool', 'supporter': 'Supporter',
            'basic': 'Basic', 'ex': 'EX', 'stage1': 'Stage 1', 'stage2': 'Stage 2'
        };
        
        const multiWordStageKeywords = {
            'stage 1': 'Stage 1', 'stage 2': 'Stage 2', 'ultra beast': 'Ultra Beast'
        };
        
        const rarityKeywords = {
            'shiny': '✵✵',  // Map to the UI display value
            'crown': 'Crown Rare'
        };
        
        const setKeywords = {
            'promo': 'Promo-A'
        };
        
        // Check multi-word keywords first
        let currentSearch = searchText.toLowerCase().trim();
        let foundKeywords = {
            energyTypes: [],
            cardType: null,
            stageType: null,
            rarity: null,
            set: null
        };
        
        // Collect all potential stage types found in the search
        let foundStageTypes = [];
        
        // Check multi-word stage keywords
        for (const [keyword, value] of Object.entries(multiWordStageKeywords)) {
            if (currentSearch.includes(keyword)) {
                foundStageTypes.push(value);
            }
        }
        
        // Split into terms for single-word matching
        const terms = currentSearch.split(/\s+/);
        
        for (const term of terms) {
            if (energyTypeKeywords[term]) {
                foundKeywords.energyTypes.push(energyTypeKeywords[term]);
            }
            if (cardTypeKeywords[term]) {
                foundKeywords.cardType = cardTypeKeywords[term];
            }
            if (singleWordStageKeywords[term]) {
                foundStageTypes.push(singleWordStageKeywords[term]);
            }
            if (rarityKeywords[term]) {
                foundKeywords.rarity = rarityKeywords[term];
            }
            if (setKeywords[term]) {
                foundKeywords.set = setKeywords[term];
            }
        }
        
        // Only set stage type filter if exactly one stage type was found
        // If multiple stage types are found, let the server handle it as text search
        if (foundStageTypes.length === 1) {
            foundKeywords.stageType = foundStageTypes[0];
        }
        
        return foundKeywords;
    }
    
    function updateUIFromKeywords(keywords) {
        // If search is completely empty, reset only typed filters
        if (rawSearchText === '') {
            // Reset only filters that were set via typing
            if (typedFilters.has('cardType')) {
                selectedFilters.cardType = 'All';
                typedFilters.delete('cardType');
            }
            if (typedFilters.has('stageType')) {
                selectedFilters.stageType = 'All';
                typedFilters.delete('stageType');
            }
            if (typedFilters.has('rarity')) {
                selectedFilters.rarity = 'All';
                typedFilters.delete('rarity');
            }
            if (typedFilters.has('set')) {
                selectedFilters.set = 'All';
                typedFilters.delete('set');
            }
            
            // Clear typed energy types and remove them from selection
            typedEnergyTypes.forEach(energyType => {
                selectedFilters.energyTypes = selectedFilters.energyTypes.filter(type => type !== energyType);
                const icon = document.querySelector(`.filter-bar .energy-icon-wrapper[data-type="${energyType}"]`);
                if (icon) {
                    icon.classList.remove('active', 'typed');
                }
            });
            typedEnergyTypes.clear();
            
            // Reset UI dropdowns only for filters that were typed
            if (selectedFilters.cardType === 'All') {
                const button1 = document.getElementById('cardTypeDropdown');
                if (button1 && button1.querySelector('.btn-text')) {
                    button1.querySelector('.btn-text').textContent = 'All';
                }
                document.querySelectorAll('#card-type-dropdown a').forEach(item => {
                    item.classList.remove('active');
                    if (item.dataset.value === 'All') {
                        item.classList.add('active');
                    }
                });
            }
            if (selectedFilters.stageType === 'All') {
                const button2 = document.getElementById('stageTypeDropdown');
                if (button2 && button2.querySelector('.btn-text')) {
                    button2.querySelector('.btn-text').textContent = 'All';
                }
                document.querySelectorAll('#stage-type-dropdown a').forEach(item => {
                    item.classList.remove('active');
                    if (item.dataset.value === 'All') {
                        item.classList.add('active');
                    }
                });
            }
            if (selectedFilters.rarity === 'All') {
                const button3 = document.getElementById('rarityDropdown');
                if (button3 && button3.querySelector('.btn-text')) {
                    button3.querySelector('.btn-text').textContent = 'All';
                }
                document.querySelectorAll('#rarity-dropdown a').forEach(item => {
                    item.classList.remove('active');
                    if (item.dataset.value === 'All') {
                        item.classList.add('active');
                    }
                });
            }
            if (selectedFilters.set === 'All') {
                const button4 = document.getElementById('setDropdown');
                if (button4 && button4.querySelector('.btn-text')) {
                    button4.querySelector('.btn-text').textContent = 'All';
                }
                document.querySelectorAll('#set-dropdown a').forEach(item => {
                    item.classList.remove('active');
                    if (item.dataset.value === 'All') {
                        item.classList.add('active');
                    }
                });
            }
            return;
        }
        
        // Remove typed filters that are no longer in search keywords
        if (typedFilters.has('cardType') && !keywords.cardType) {
            selectedFilters.cardType = 'All';
            typedFilters.delete('cardType');
        }
        if (typedFilters.has('stageType') && !keywords.stageType) {
            selectedFilters.stageType = 'All';
            typedFilters.delete('stageType');
        }
        if (typedFilters.has('rarity') && !keywords.rarity) {
            selectedFilters.rarity = 'All';
            typedFilters.delete('rarity');
        }
        if (typedFilters.has('set') && !keywords.set) {
            selectedFilters.set = 'All';
            typedFilters.delete('set');
        }
        
        // Remove typed energy types that are no longer in search keywords
        const currentTypedEnergyTypes = new Set(typedEnergyTypes);
        currentTypedEnergyTypes.forEach(energyType => {
            if (!keywords.energyTypes.includes(energyType)) {
                typedEnergyTypes.delete(energyType);
                selectedFilters.energyTypes = selectedFilters.energyTypes.filter(type => type !== energyType);
                const icon = document.querySelector(`.filter-bar .energy-icon-wrapper[data-type="${energyType}"]`);
                if (icon) {
                    icon.classList.remove('active', 'typed');
                }
            }
        });
        
        // Update energy type icons - preserve existing selections and add new ones
        if (keywords.energyTypes.length > 0) {
            keywords.energyTypes.forEach(energyType => {
                const icon = document.querySelector(`.filter-bar .energy-icon-wrapper[data-type="${energyType}"]`);
                if (icon && !icon.classList.contains('active')) {
                    icon.classList.add('active');
                    if (!selectedFilters.energyTypes.includes(energyType)) {
                        selectedFilters.energyTypes.push(energyType);
                    }
                }
                // Mark this energy type as typed and add visual indicator
                if (icon) {
                    icon.classList.add('typed');
                }
                typedEnergyTypes.add(energyType);
            });
        }
        
        // Update card type dropdown
        if (keywords.cardType) {
            selectedFilters.cardType = keywords.cardType;
            typedFilters.add('cardType'); // Mark as typed
            const button = document.getElementById('cardTypeDropdown');
            if (button && button.querySelector('.btn-text')) {
                button.querySelector('.btn-text').textContent = keywords.cardType;
            }
            // Update dropdown active state
            document.querySelectorAll('#card-type-dropdown a').forEach(item => {
                item.classList.remove('active');
                if (item.textContent.trim() === keywords.cardType) {
                    item.classList.add('active');
                }
            });
        }
        
        // Update stage type dropdown
        if (keywords.stageType) {
            selectedFilters.stageType = keywords.stageType;
            typedFilters.add('stageType'); // Mark as typed
            const button = document.getElementById('stageTypeDropdown');
            if (button && button.querySelector('.btn-text')) {
                button.querySelector('.btn-text').textContent = keywords.stageType;
            }
            // Update dropdown active state
            document.querySelectorAll('#stage-type-dropdown a').forEach(item => {
                item.classList.remove('active');
                if (item.textContent.trim() === keywords.stageType) {
                    item.classList.add('active');
                }
            });
        }
        
        // Update rarity dropdown
        if (keywords.rarity) {
            selectedFilters.rarity = keywords.rarity;
            typedFilters.add('rarity'); // Mark as typed
            const button = document.getElementById('rarityDropdown');
            if (button && button.querySelector('.btn-text')) {
                const btnText = button.querySelector('.btn-text');
                // Special handling for Crown Rare emoji
                if (keywords.rarity === 'Crown Rare') {
                    btnText.textContent = '👑';
                } else {
                    btnText.textContent = keywords.rarity;
                }
            }
            // Update dropdown active state
            document.querySelectorAll('#rarity-dropdown a').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.value === keywords.rarity) {
                    item.classList.add('active');
                }
            });
        }
        
        // Update set dropdown
        if (keywords.set) {
            selectedFilters.set = keywords.set;
            typedFilters.add('set'); // Mark as typed
            const button = document.getElementById('setDropdown');
            if (button && button.querySelector('.btn-text')) {
                button.querySelector('.btn-text').textContent = keywords.set;
            }
            // Update dropdown active state
            document.querySelectorAll('#set-dropdown a').forEach(item => {
                item.classList.remove('active');
                if (item.textContent.trim() === keywords.set) {
                    item.classList.add('active');
                }
            });
        }
    }


    // Search spinner functions for server requests
    function showSearchInputSpinner() {
        const searchIcon = document.querySelector('.input-group-text i.bi-search');
        if (searchIcon && !searchIcon.classList.contains('spinner-border')) {
            searchIcon.className = 'spinner-border spinner-border-sm';
        }
    }

    function hideSearchInputSpinner() {
        const searchSpinner = document.querySelector('.input-group-text .spinner-border');
        if (searchSpinner) {
            searchSpinner.className = 'bi bi-search';
        }
    }

    function setupEventListeners() {
        // Search input - shows spinner during server requests (like collection.html)
        const debouncedFilter = debounce(() => {
            showSearchInputSpinner();
            
            rawSearchText = document.getElementById('search-input').value.toLowerCase();
            
            // Parse keywords and update UI
            const keywords = parseSearchKeywords(rawSearchText);
            updateUIFromKeywords(keywords);
            
            resetAddCardsScroll();
            applyFilters();
        }, 300);

        document.getElementById('search-input').addEventListener('input', debouncedFilter);

        // Dropdown listeners (using the helper function for filter dropdowns)
        setupDropdownListeners(); // Handles cardType, stageType, rarity, set dropdowns

        // --- FINAL: Filter and Deck Energy Icons (using pointerdown) ---

        // 1. Handler for the FILTER energy icons
        const handleFilterEnergySelect = function(event) {
            const icon = event.currentTarget;
            const energyType = icon.getAttribute('data-type');
            resetAddCardsScroll();

            // Prevent unselecting typed energy types
            if (icon.classList.contains('active') && typedEnergyTypes.has(energyType)) {
                return; // Don't allow unselecting typed energy types
            }

            icon.classList.toggle('active');

            if (icon.classList.contains('active')) {
                if (!selectedFilters.energyTypes.includes(energyType)) {
                    selectedFilters.energyTypes.push(energyType);
                }
            } else {
                selectedFilters.energyTypes = selectedFilters.energyTypes.filter(type => type !== energyType);
            }
            applyFilters();
        };

        document.querySelectorAll('.filter-bar .energy-icon-wrapper').forEach(icon => {
            icon.addEventListener('pointerdown', handleFilterEnergySelect);
        });

        // 2. Handler for the DECK energy icons
        const handleDeckEnergySelect = function(event) {
            const icon = event.currentTarget;
            const energyType = icon.getAttribute('data-type');

            if (icon.classList.contains('active')) {
                icon.classList.remove('active');
                selectedDeckEnergies = selectedDeckEnergies.filter(type => type !== energyType);
                deckSaved = false;
            } else {
                if (selectedDeckEnergies.length < 3) {
                    icon.classList.add('active');
                    if (!selectedDeckEnergies.includes(energyType)) {
                        selectedDeckEnergies.push(energyType);
                    }
                    deckSaved = false;
                } else {
                    if (window.showGlobalToast) {
                        window.showGlobalToast("You can only select up to 3 energy types for your deck.", "default");
                    }
                }
            }
            updateEnergyCounter();
            
            // Trigger mobile auto-save when energy selection changes (even without cards)
            if (window.matchMedia("(hover: none)").matches) {
                triggerMobileAutoSave();
            }
        };

        document.querySelectorAll('.energy-selection-bar .deck-energy').forEach(icon => {
            icon.addEventListener('pointerdown', handleDeckEnergySelect);
        });

        // --- Correctly placed and singular Sort Dropdown Click Handler ---
        const sortDropdownMenu = document.getElementById('sort-options-dropdown');
        if (sortDropdownMenu) {
            sortDropdownMenu.addEventListener('click', function(e) {
                const link = e.target.closest('a.dropdown-item');
                if (link && link.dataset.sortType) {
                    e.preventDefault();
                    const clickedSortType = link.dataset.sortType;
                    if (clickedSortType === currentSortType) {
                        sortTypeDirections[currentSortType] = (sortTypeDirections[currentSortType] === 'asc') ? 'desc' : 'asc';
                        currentSortDirection = sortTypeDirections[currentSortType];
                    } else {
                        currentSortType = clickedSortType;
                        currentSortDirection = sortTypeDirections[currentSortType];
                    }
                    updateSortDropdownUI();
                    applyFilters();
                    const sortButton = document.getElementById('sortDropdownButton');
                    if (sortButton && typeof bootstrap !== 'undefined' && bootstrap.Dropdown) {
                        const bsDropdownInstance = bootstrap.Dropdown.getInstance(sortButton);
                        if (bsDropdownInstance) {
                            bsDropdownInstance.hide();
                        }
                    }
                }
            });
        }
        // --- End of Sort Dropdown Click Handler ---

        // Global click debugging to see ALL clicks
        document.addEventListener('click', function(e) {
            // Debug object removed for performance
        }, true); // Use capture phase
        
        // Consolidated Click Listener using Event Delegation
        document.addEventListener('click', function(e) {

            // --- Handle Deck Card Remove Button (-) ---
            const removeBtn = e.target.closest('.btn-remove');
            if (removeBtn) {
                // --- ADDED FOR MOBILE TAP ANIMATION ---
                removeBtn.classList.add('is-tapping');
                setTimeout(() => removeBtn.classList.remove('is-tapping'), 170);
                // --- END ANIMATION CODE ---

                e.stopPropagation();
                const cardSlot = removeBtn.closest('.card-slot');
                const cardImage = cardSlot ? cardSlot.querySelector('img') : null;
                const cardContainer = cardSlot ? cardSlot.querySelector('.card-slot-container') : null;

                if (cardSlot && cardImage && cardContainer && cardContainer.dataset.cardId) {
                    const slotIndex = Array.from(cardSlot.parentNode.children).indexOf(cardSlot);
                    const removedCardId = parseInt(cardContainer.dataset.cardId, 10);

                    if (slotIndex !== -1 && slotIndex < currentDeck.length) {
                        currentDeck.splice(slotIndex, 1);
                        deckSaved = false;

                        // Clean up cover cards if necessary
                        cleanupCoverCardsAfterRemoval(removedCardId);
                        
                        updateDeckDisplay();
                        updateCardStateInCollection(removedCardId);
                    }
                }
                return;
            }

            // --- Handle Collection Card Remove Button (-) ---
            const removeSmallBtn = e.target.closest('.btn-remove-small');
            if (removeSmallBtn) {
                // --- ADDED FOR MOBILE TAP ANIMATION ---
                removeSmallBtn.classList.add('is-tapping');
                setTimeout(() => removeSmallBtn.classList.remove('is-tapping'), 170);
                // --- END ANIMATION CODE ---

                e.stopPropagation();
                const cardItem = removeSmallBtn.closest('.card-item');
                if (cardItem && cardItem.dataset.cardId) {
                    const cardIdToRemove = parseInt(cardItem.dataset.cardId, 10);
                    const indexToRemove = currentDeck.findIndex(card => card.id === cardIdToRemove);

                    if (indexToRemove !== -1) {
                        currentDeck.splice(indexToRemove, 1);
                        deckSaved = false;
                        
                        // Clean up cover cards if necessary
                        cleanupCoverCardsAfterRemoval(cardIdToRemove);
                        
                        updateDeckDisplay();
                        updateCardStateInCollection(cardIdToRemove);
                    }
                }
                return;
            }

            // --- Handle Favorite Button (Star) Click ---
            const favoriteBtn = e.target.closest('.btn-favorite');
            if (favoriteBtn) {
                e.stopPropagation(); 
                const clickedCardIdStr = favoriteBtn.dataset.cardId;
                if (!clickedCardIdStr) { return; }
                const clickedCardId = clickedCardIdStr;
                const idIndex = coverCardIds.indexOf(clickedCardId);
                if (idIndex > -1) {
                    coverCardIds.splice(idIndex, 1);
                } else {
                    if (coverCardIds.length < 3) {
                        coverCardIds.push(clickedCardId);
                    } else {
                        if (window.showGlobalToast) {
                            window.showGlobalToast("You can only select up to 3 cover cards.", "default");
                        } else {
                            alert("You can only select up to 3 cover cards.");
                        }
                        return;
                    }
                }
                deckSaved = false;
                setCoverCardStarVisuals();
                return;
            }

            // --- Handle Collection Card Add Click ---
            const cardImage = e.target.closest('.card-item img');
            
            if (cardImage && !e.target.closest('.btn-remove-small')) {
                const cardItem = cardImage.closest('.card-item');
                const cardContainer = cardItem ? cardItem.querySelector('.position-relative') : null;

                if (cardItem && cardItem.dataset.cardId && cardContainer) {
                    
                    // Always try to load high-res image when card is tapped (on mobile)
                    const isMobile = window.matchMedia("(hover: none)").matches;
                    if (isMobile) {
                        const img = cardItem.querySelector('img');
                        if (img && img.dataset.loadedResolution !== 'high') {
                            loadHighResForMobile(img);
                        }
                    }
                    
                    if (cardContainer.classList.contains('max-copies')) {
                        const cardName = cardItem.dataset.cardName;
                        if (window.showGlobalToast) {
                            window.showGlobalToast(`Max 2 copies of '${cardName}' allowed.`, "default");
                        }
                    } else {
                        addCardToDeck(cardItem.dataset.cardId, cardItem);
                    }
                } else {
                    // Debug info removed for performance
                }
                return;
            }

        }); // End of consolidated delegated click listener

        // Clear deck button
        document.getElementById('clear-deck-btn').addEventListener('click', clearDeck);

        // Save deck button
        document.getElementById('save-deck-btn').addEventListener('click', saveDeck);


        // Deck name input changes -> mark as unsaved
        document.getElementById('deck-name').addEventListener('input', () => { deckSaved = false; });
        

        // Card hover zoom
        setupCardZoom();

        if (window.matchMedia("(hover: none)").matches) {
            // Enhanced mobile auto-save with better persistence
            const autoSaveDeck = () => {
                triggerMobileAutoSave();
                // Silent auto-save - no notification needed
            };

            // Save on visibility change (app backgrounding)
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'hidden') {
                    autoSaveDeck();
                }
            });

            // Also save periodically while editing (every 60 seconds)
            let autoSaveInterval = setInterval(autoSaveDeck, 60000);
            
            // Clean up interval when deck is saved or page unloads
            const cleanupAutoSave = () => {
                if (autoSaveInterval) {
                    clearInterval(autoSaveInterval);
                    autoSaveInterval = null;
                }
            };
            
            window.addEventListener('beforeunload', cleanupAutoSave);
        } else {
            window.addEventListener('beforeunload', function(e) {
                if (!deckSaved && !isDeckPristineOrEmpty()) {
                    e.preventDefault();
                    e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
                }
            });
        }
    }

    function updateEnergyCounter() {
        const counterElem = document.querySelector('.selected-energies-info');
        if (counterElem) {
            counterElem.textContent = `${selectedDeckEnergies.length}/3 energy types selected`;
        }
    }

    function setupCardZoom() {
        // Check if the primary input method can hover. If not (it's a touch device),
        // do not set up any zoom listeners and exit the function immediately.
        if (window.matchMedia("(hover: none)").matches) {
            return;
        }

        // Variables to track mouse movement
        let isScrolling = false;
        let hasMouseMoved = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // Detect scrolling
        window.addEventListener('scroll', function() {
            // Set scrolling flag to true and hide zoom
            isScrolling = true;
            hasMouseMoved = false;
            hideCardZoom();
        });

        // Track mouse movement to detect when user moves mouse after scrolling
        document.addEventListener('mousemove', function(e) {
            // Check if the mouse has moved significantly from last position
            const mouseMoved = Math.abs(e.clientX - lastMouseX) > 5 || Math.abs(e.clientY - lastMouseY) > 5;

            // If scrolling and mouse has moved, we can enable zoom again
            if (isScrolling && mouseMoved) {
                isScrolling = false;
                hasMouseMoved = true;
            }

            // Update last mouse position
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;

            // Only show zoom if not scrolling
            if (!isScrolling) {
                // First check if the target itself is an image
                if (e.target.tagName === 'IMG') {
                    const cardElement = e.target.closest(".card-item") || e.target.closest(".card-slot-container.filled");
                    if (cardElement) {
                        showCardZoom(e.target, e); // Pass the hovered <img> element
                        return;
                    }
                }

                // If we get here, no image was hovered, so hide zoom
                hideCardZoom();
            }
        });

        // Hide zoom when mouse leaves any card image
        document.addEventListener('mouseout', function(e) {
            if (e.target.tagName === 'IMG' &&
                (e.target.closest('.card-item') || e.target.closest('.card-slot-container.filled'))) {
                hideCardZoom();
            }
        });
    }

    function showCardZoom(hoveredImgElement, event) {
        const cardElement = hoveredImgElement.closest('.card-item') || hoveredImgElement.closest('.card-slot-container.filled');
        if (!cardElement) {
            // No card element found
            return;
        }

        const highResSrc = cardElement.dataset.highResSrc;
        const lowResSrc = hoveredImgElement.src;
        
        // Hover detected on card

        // Early return if no high-res source available
        if (!highResSrc || highResSrc === 'undefined' || highResSrc === 'null') {
            return;
        }

        const zoomContainer = document.getElementById('card-zoom-container');
        if (!zoomContainer) {
            return;
        }

        let zoomImg = zoomContainer.querySelector('img');
        if (!zoomImg) {
            zoomImg = document.createElement('img');
            zoomContainer.appendChild(zoomImg);
            // [ZOOM] Created new zoom image element');
        }

        // Always clear any pending high-res download from a previous hover.
        clearTimeout(highResLoadTimeout);
        zoomContainer.dataset.intendedSrc = highResSrc;

        // Use proxy URLs for both standard and high-res versions
        const lowResProxyUrl = lowResSrc;
        const highResProxyUrl = getImageUrl(highResSrc);
        
        // [ZOOM] URL Processing complete

        // Check if high-res is already cached or if the thumbnail is already high-res
        const isCached = highResImageCache.has(highResSrc);
        const isAlreadyHighRes = hoveredImgElement.dataset.loadedResolution === 'high';
        
        // [ZOOM] Cache check complete
        
        if (isCached || isAlreadyHighRes) {
            // If cached or thumbnail is already high-res, show high-res instantly and update thumbnail if needed
            // [ZOOM] Using cached/existing high-res image');
            zoomImg.src = highResProxyUrl;
            if (hoveredImgElement.dataset.loadedResolution !== 'high') {
                // [ZOOM] Updating thumbnail to high-res (from cache)');
                hoveredImgElement.src = highResProxyUrl;
                hoveredImgElement.dataset.loadedResolution = 'high';
            }
        } else {
            // If not cached, show low-res instantly
            // [ZOOM] Loading high-res image (not cached)');
            zoomImg.src = lowResProxyUrl;
            
            // Schedule the high-res download to start after a delay
            highResLoadTimeout = setTimeout(() => {
                // [ZOOM] Starting high-res download
                const highResImage = new Image();
                highResImage.src = highResProxyUrl;
                highResImage.onload = () => {
                    // [ZOOM] High-res image loaded successfully');
                    highResImageCache.add(highResSrc);
                    if (zoomContainer.style.display === 'block' && zoomContainer.dataset.intendedSrc === highResSrc) {
                        // [ZOOM] Updating zoom image to high-res
                        zoomImg.src = highResProxyUrl;
                    }
                    
                    // Also update the thumbnail with high-res version
                    if (hoveredImgElement && hoveredImgElement.parentElement) {
                        // [ZOOM] Updating thumbnail to high-res (after download)
                        hoveredImgElement.src = highResProxyUrl;
                        hoveredImgElement.dataset.loadedResolution = 'high';
                        
                        // Update any matching cards in the deck display
                        const originalSrc = hoveredImgElement.dataset.originalSrc || hoveredImgElement.getAttribute('data-original-src');
                        if (originalSrc) {
                            // [ZOOM] Updating matching deck images
                            updateDeckImagesWithHighRes(originalSrc, highResProxyUrl);
                        }
                    }
                };
                highResImage.onerror = () => {
                    // Error logging removed for performance
                };
            }, 250); 
        }

        // Positioning logic remains the same...
        const cardRect = cardElement.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const isSmallScreen = window.innerWidth <= 800;
        const cssZoomMaxWidth = isSmallScreen ? 260 : 340;
        const cssZoomMaxHeight = viewportHeight * 0.90;
        let calculatedZoomWidth = cssZoomMaxWidth;
        let calculatedZoomHeight = cssZoomMaxWidth / (63 / 88);
        if (calculatedZoomHeight > cssZoomMaxHeight) {
            calculatedZoomHeight = cssZoomMaxHeight;
            calculatedZoomWidth = calculatedZoomHeight * (63 / 88);
        }
        calculatedZoomWidth = Math.min(calculatedZoomWidth, cssZoomMaxWidth);
        const cardCenterX = cardRect.left + cardRect.width / 2;
        const cardCenterY = cardRect.top + cardRect.height / 2;
        const margin = 15;
        let zoomLeft, zoomTop;
        if (isSmallScreen) {
            const spaceRightAvailable = viewportWidth - cardRect.right - margin;
            const spaceLeftAvailable = cardRect.left - margin;
            if (cardCenterX < viewportWidth / 2) {
                if (spaceRightAvailable >= calculatedZoomWidth) {
                    zoomLeft = cardRect.right + margin;
                } else if (spaceLeftAvailable >= calculatedZoomWidth) {
                    zoomLeft = cardRect.left - calculatedZoomWidth - margin;
                } else {
                    zoomLeft = (viewportWidth - calculatedZoomWidth) / 2;
                }
            } else {
                if (spaceLeftAvailable >= calculatedZoomWidth) {
                    zoomLeft = cardRect.left - calculatedZoomWidth - margin;
                } else if (spaceRightAvailable >= calculatedZoomWidth) {
                    zoomLeft = cardRect.right + margin;
                } else {
                    zoomLeft = (viewportWidth - calculatedZoomWidth) / 2;
                }
            }
        } else {
            const isInDeck = cardElement.closest('.current-deck-wrapper') !== null;
            if (isInDeck) {
                zoomLeft = cardRect.left - calculatedZoomWidth - margin;
                if (zoomLeft < margin) {
                    zoomLeft = cardRect.right + margin;
                    if (zoomLeft + calculatedZoomWidth > viewportWidth - margin) {
                        zoomLeft = (viewportWidth - calculatedZoomWidth) / 2;
                    }
                }
            } else {
                zoomLeft = cardRect.right + margin;
                if (zoomLeft + calculatedZoomWidth > viewportWidth - margin) {
                    zoomLeft = cardRect.left - calculatedZoomWidth - margin;
                    if (zoomLeft < margin) {
                        zoomLeft = (viewportWidth - calculatedZoomWidth) / 2;
                    }
                }
            }
        }
        zoomLeft = Math.max(margin, zoomLeft);
        zoomLeft = Math.min(zoomLeft, viewportWidth - calculatedZoomWidth - margin);
        zoomTop = cardCenterY - (calculatedZoomHeight / 2);
        if (zoomTop < margin) {
            zoomTop = margin;
        } else if (zoomTop + calculatedZoomHeight > viewportHeight - margin) {
            zoomTop = viewportHeight - calculatedZoomHeight - margin;
        }
        zoomTop = Math.max(margin, zoomTop);
        zoomContainer.style.top = zoomTop + 'px';
        zoomContainer.style.left = zoomLeft + 'px';
        zoomContainer.style.display = 'block';
    }

    function hideCardZoom() {
        // [ZOOM] Hiding zoom');
        const zoomContainer = document.getElementById('card-zoom-container');
        if (zoomContainer) {
            zoomContainer.style.display = 'none';
            zoomContainer.dataset.intendedSrc = '';
            // Cancel any pending high-res download.
            clearTimeout(highResLoadTimeout);
            // [ZOOM] Zoom hidden and timeout cleared');
        } else {
            // [ZOOM] No zoom container to hide');
        }
    }

    // Debounced apply filters function for server-side filtering
    const debouncedApplyFilters = debounce(() => {
        resetPaginationAndLoadCards();
    }, 300);

    function applyFilters() {
        debouncedApplyFilters();
    }

    // Reset pagination and load first page with current filters
    function resetPaginationAndLoadCards() {
        currentPage = 1;
        hasMoreCards = true;
        loadedIds.clear();
        
        // Disconnect infinite scroll observer
        if (window.scrollObserver) {
            window.scrollObserver.disconnect();
        }
        
        loadCardsPage(1, false);
    }


    function resetAddCardsScroll() {
        const cardCollectionDiv = document.getElementById('card-collection');
        if (cardCollectionDiv) {
            cardCollectionDiv.scrollTop = 0;
        }
    }

    function updateCardDisplay(isAppend = false, isInitialLoad = false) {
        const cardCollection = document.getElementById('card-collection');
        if (!cardCollection) {
            return;
        }

        let rowDiv;
        let noResultsDiv;
        
        if (isAppend) {
            // For append mode, find existing row
            rowDiv = cardCollection.querySelector('.row');
            noResultsDiv = cardCollection.querySelector('.no-results-message');
            if (!rowDiv) {
                rowDiv = document.createElement('div');
                rowDiv.className = 'row g-2';
                cardCollection.appendChild(rowDiv);
            }
        } else {
            // For non-append mode, create new elements
            rowDiv = document.createElement('div');
            rowDiv.className = 'row g-2';
            
            noResultsDiv = document.createElement('div');
            noResultsDiv.className = 'col-12 text-center p-5 no-results-message';

            const message = document.createElement('p');
            message.className = 'mb-4';
            message.textContent = 'No cards found with the current filters.';
            const resetButton = document.createElement('button');
            resetButton.className = 'btn btn-primary';
            resetButton.textContent = 'Reset All Filters';
            resetButton.addEventListener('click', resetAllFilters);
            noResultsDiv.appendChild(message);
            noResultsDiv.appendChild(resetButton);
        }
        
        // When appending, only process new cards that aren't already displayed
        const displayedCardIds = isAppend ? new Set(
            Array.from(cardCollection.querySelectorAll('.card-item')).map(el => el.dataset.cardId)
        ) : new Set();
        
        const cardsToDisplay = isAppend ? 
            filteredCards.filter(card => !displayedCardIds.has(card.id.toString())) : 
            filteredCards;
            
            cardsToDisplay.forEach((card, index) => {
                
                const colDiv = document.createElement('div');
                colDiv.className = 'col-4 col-sm-4 col-md-4 col-lg-3 col-xl-2 mb-3 card-item';
                colDiv.dataset.cardId = card.id;
                colDiv.dataset.cardName = card.name;
                // Set high-res source, with fallback if not available
                const generatedHighRes = getHighResUrl(card.display_image_path);
                const cardHighResSrc = card.high_res_image_path || generatedHighRes;
                
                // Only set if we have a valid high-res URL
                if (cardHighResSrc) {
                    colDiv.dataset.highResSrc = cardHighResSrc;
                }
                
                // Debug logging removed for production
                const cardContainer = document.createElement('div');
                cardContainer.className = 'position-relative clickable-card is-loading'; // Will be removed later if cached

                const img = document.createElement('img');
                img.alt = card.name;
                img.className = 'img-fluid rounded';
                img.setAttribute('data-card-name', card.name);
                
                // For debugging: force load images immediately in paginated system
                
                // Check if high-res version is cached and use it if available
                const highResSrc = getHighResUrl(card.display_image_path);
                let imageToLoad = card.display_image_path;
                let isHighRes = false;
                
                if (highResSrc && highResImageCache.has(highResSrc)) {
                    imageToLoad = highResSrc;
                    isHighRes = true;
                    // Don't remove loading state immediately - let onload handler do it
                    // This ensures shimmer is visible even for cached images
                }
                
                img.src = imageToLoad; // Load immediately instead of lazy loading
                // img.setAttribute('data-src', card.display_image_path); // Commented out lazy loading for now
                img.setAttribute('data-original-src', card.display_image_path); // Store for mobile loading
                
                // Mark as high-res if we loaded the cached version
                if (isHighRes) {
                    img.dataset.loadedResolution = 'high';
                }
                
                // Add loading handlers to remove loading state with minimum delay
                img.onload = () => {
                    // Ensure shimmer is visible for at least 200ms
                    setTimeout(() => {
                        cardContainer.classList.remove('is-loading');
                        cardContainer.classList.add('is-loaded');
                    }, 200);
                };
                img.onerror = () => {
                    cardContainer.classList.remove('is-loading');
                    cardContainer.classList.add('error-loading');
                };

                cardContainer.appendChild(img);
                colDiv.appendChild(cardContainer);
                rowDiv.appendChild(colDiv);

                if (cardObserver) {
                    cardObserver.observe(colDiv);
                }
            });
            
            if (!isAppend) {
                if (isInitialLoad) {
                    const existingRow = cardCollection.querySelector('.row');
                    if (existingRow) {
                        // Get existing shimmer cards and new real cards
                        const existingCards = Array.from(existingRow.querySelectorAll('.card-item'));
                        const newCards = Array.from(rowDiv.querySelectorAll('.card-item'));
                        
                        // Transform shimmer cards into real cards by updating their content
                        newCards.forEach((newCard, index) => {
                            if (existingCards[index]) {
                                const existingContainer = existingCards[index].querySelector('.clickable-card');
                                const newContainer = newCard.querySelector('.clickable-card');
                                
                                if (existingContainer && newContainer) {
                                    // Copy all data attributes from new card to existing card
                                    Array.from(newCard.attributes).forEach(attr => {
                                        if (attr.name.startsWith('data-')) {
                                            existingCards[index].setAttribute(attr.name, attr.value);
                                        }
                                    });
                                    
                                    // Get the image from the new card
                                    const newImg = newContainer.querySelector('img');
                                    if (newImg) {
                                        // Add the image to the existing shimmer container
                                        existingContainer.appendChild(newImg);
                                        
                                        // When image loads, remove shimmer state
                                        newImg.onload = () => {
                                            setTimeout(() => {
                                                existingContainer.classList.remove('is-loading');
                                                existingContainer.classList.add('is-loaded');
                                            }, 200);
                                        };
                                        newImg.onerror = () => {
                                            existingContainer.classList.remove('is-loading');
                                            existingContainer.classList.add('error-loading');
                                        };
                                    }
                                } else {
                                    // Fallback: replace entire card if structure is different
                                    existingRow.insertBefore(newCard, existingCards[index]);
                                    existingRow.removeChild(existingCards[index]);
                                }
                            } else {
                                // Add any extra cards to the end
                                existingRow.appendChild(newCard);
                            }
                        });
                        
                        // Remove any leftover shimmer cards
                        existingCards.slice(newCards.length).forEach(card => {
                            if (card.parentNode) {
                                existingRow.removeChild(card);
                            }
                        });
                    } else {
                        // Fallback if no existing row found
                        cardCollection.innerHTML = '';
                        cardCollection.appendChild(rowDiv);
                    }
                } else {
                    cardCollection.innerHTML = '';
                    cardCollection.appendChild(rowDiv);
                    if (noResultsDiv) {
                        cardCollection.appendChild(noResultsDiv);
                    }
                }
            }
            
            // Debug: Check if elements are actually in DOM
            setTimeout(() => {
                const createdCards = cardCollection.querySelectorAll('.card-item');
                const createdImages = cardCollection.querySelectorAll('.card-item img');
                
                // Check first image specifically
                if (createdImages.length > 0) {
                    // Debug info for first image removed for performance
                }
            }, 50);
            
            // cardCollection.dataset.isBuilt = 'true'; // Removed for paginated system
        // }

        // Handle deck restoration highlighting
        if (deckWasRestored) {
            const uniqueCardIdsInDeck = [...new Set(currentDeck.map(card => card.id))];
            uniqueCardIdsInDeck.forEach(cardId => {
                updateCardStateInCollection(cardId);
            });
            deckWasRestored = false;
        }

        // Show/hide no results message
        const noResultsMessage = cardCollection.querySelector('.no-results-message');
        if (noResultsMessage) {
            const visibleCount = filteredCards.length;
            noResultsMessage.style.display = visibleCount === 0 ? 'block' : 'none';
        }

        // Update card count display
        const visibleCount = filteredCards.length;
        document.getElementById('card-count-search').textContent = `${visibleCount} ${visibleCount === 1 ? 'card' : 'cards'}`;
        
        // Add infinite scroll sentinel if it doesn't exist
        if (hasMoreCards && !cardCollection.querySelector('.scroll-sentinel')) {
            setupInfiniteScroll();
        }
        
        // IMPORTANT: Restore badges and remove buttons for cards already in deck
        // This ensures that after pagination reloads, cards maintain their visual state
        if (currentDeck && currentDeck.length > 0) {
            const uniqueCardIdsInDeck = [...new Set(currentDeck.map(card => card.id))];
            uniqueCardIdsInDeck.forEach(cardId => {
                updateCardStateInCollection(cardId);
            });
        }
    }
    
    function updateCardStateInCollection(cardId) {
        const cardData = allCards.find(c => c.id == cardId);
        if (!cardData) return;
        const cardName = cardData.name;

        const cardElements = document.querySelectorAll(`.card-item[data-card-name="${cardName}"]`);
        if (cardElements.length === 0) return;

        const copiesInDeckByName = currentDeck.filter(deckCard => deckCard.name === cardName).length;
        const isMaxedOut = copiesInDeckByName >= 2;

        cardElements.forEach(cardEl => {
            const cardContainer = cardEl.querySelector('.position-relative');
            if (!cardContainer) return;

            // More explicit class management
            if (isMaxedOut) {
                cardContainer.classList.add('max-copies');
                cardContainer.classList.remove('clickable-card');
            } else {
                cardContainer.classList.remove('max-copies');
                cardContainer.classList.add('clickable-card');
            }

            // The rest of your badge and remove button logic is perfect and can stay as-is.
            const specificCardId = cardEl.dataset.cardId;
            const exactCopiesOfThisIdInDeck = currentDeck.filter(c => c.id.toString() === specificCardId).length;

            let badge = cardContainer.querySelector('.badge');
            if (exactCopiesOfThisIdInDeck > 0) {
                if (!badge) {
                    badge = document.createElement('div');
                    badge.className = 'position-absolute top-0 start-0 badge bg-primary rounded-circle m-1';
                    cardContainer.appendChild(badge);
                }
                badge.textContent = `${exactCopiesOfThisIdInDeck}/2`;
            } else if (badge) {
                badge.remove();
            }

            let removeBtn = cardContainer.querySelector('.btn-remove-small');
            if (exactCopiesOfThisIdInDeck > 0) {
                if (!removeBtn) {
                    removeBtn = document.createElement('button');
                    removeBtn.className = 'btn-remove-small';
                    removeBtn.innerHTML = '-';
                    cardContainer.appendChild(removeBtn);
                }
            } else if (removeBtn) {
                removeBtn.remove();
            }
        });
    }

    function resetAllFilters() {

        // 1. Reset internal filter state
        rawSearchText = '';
        selectedFilters = {
            cardType: 'All',
            stageType: 'All',
            rarity: 'All',
            set: 'All',
            energyTypes: []
        };

        // 2. Reset UI controls directly
        // Reset search input field
        document.getElementById('search-input').value = '';

        // Reset dropdowns (button text and active menu item)
        const dropdownConfig = {
            'cardTypeDropdown': { menuId: 'card-type-dropdown', property: 'cardType' },
            'stageTypeDropdown': { menuId: 'stage-type-dropdown', property: 'stageType' },
            'rarityDropdown': { menuId: 'rarity-dropdown', property: 'rarity' },
            'setDropdown': { menuId: 'set-dropdown', property: 'set' }
        };

        Object.entries(dropdownConfig).forEach(([buttonId, config]) => {
            const button = document.getElementById(buttonId);
            const menu = document.getElementById(config.menuId);
            const resetValue = 'All'; // The value to reset to

            if (button) {
                // Find the text content corresponding to the 'All' value to set button text
                const allOption = menu ? menu.querySelector(`a[data-value="${resetValue}"]`) : null;
                button.textContent = allOption ? allOption.textContent : resetValue;
            }
            if (menu) {
                menu.querySelectorAll('a.dropdown-item').forEach(a => {
                    if (a.dataset.value === resetValue) {
                        a.classList.add('active');
                    } else {
                        a.classList.remove('active');
                    }
                });
            }
        });

        // Reset energy filter icons (remove active class)
        document.querySelectorAll('.filter-bar .energy-icons .energy-icon-wrapper.active').forEach(icon => {
            icon.classList.remove('active');
        });


        // 3. IMPORTANT: Apply the filters again now that state and UI are reset
        // This will update filteredCards and call updateCardDisplay
        applyFilters();

    }

    function countCardCopiesInDeck(cardId) {
        // First, find the card name using the ID
        const cardName = allCards.find(card => card.id === cardId)?.name;

        if (!cardName) return 0;

        // Then count all cards in the deck with that name
        return currentDeck.filter(card => card.name === cardName).length;
    }

    function cleanupCoverCardsAfterRemoval(removedCardId) {
        // Convert removedCardId to string for consistent comparison
        const removedCardIdStr = removedCardId.toString();
        
        // Count how many copies of this specific card ID remain in the deck
        const remainingCopies = currentDeck.filter(card => card.id.toString() === removedCardIdStr).length;
        
        // If no copies remain, remove this card from cover cards
        if (remainingCopies === 0) {
            const coverIndex = coverCardIds.indexOf(removedCardIdStr);
            if (coverIndex > -1) {
                coverCardIds.splice(coverIndex, 1);
                // The updateCoverCardDisplay() function will handle reordering the remaining cover cards
            }
        }
        // If copies remain, the cover card status is preserved (no action needed)
    }
    
    function addCardToDeck(cardId, clickedElement = null) {
        
        const cardItem = clickedElement;
        // --- NEW: Cooldown Check ---
        if (!cardItem || cardItem.dataset.isAnimating === 'true') {
            return;
        }

        const cardToAdd = allCards.find(c => c.id.toString() === cardId);
        
        if (!cardToAdd) { 
            return; 
        }

        const copiesInDeck = currentDeck.filter(c => c.name === cardToAdd.name).length;
        
        if (copiesInDeck >= 2) {
            return;
        }
        if (currentDeck.length >= 20) {
            if (window.showGlobalToast) {
                window.showGlobalToast("Your deck is full (20 cards max).", "default");
            }
            return;
        }
        

        // --- NEW: Set Cooldown Flag ---
        cardItem.dataset.isAnimating = 'true';

        const isMobile = window.matchMedia("(hover: none)").matches;

        const performImmediateStateUpdate = () => {
            currentDeck.push(cardToAdd);
            deckSaved = false;
            updateDeckDisplay();
        };

        if (isMobile) {
            const clickableContainer = cardItem.querySelector('.clickable-card');
            if (clickableContainer) {
                clickableContainer.classList.add('tapped-mobile');
                performImmediateStateUpdate();
                
                // Load high-res version when card is added to deck on mobile
                const img = cardItem.querySelector('img');
                if (img && img.dataset.loadedResolution !== 'high') {
                    loadHighResForMobile(img);
                }
                
                setTimeout(() => {
                    updateCardStateInCollection(cardId);
                    clickableContainer.classList.remove('tapped-mobile');
                    // --- NEW: Remove Cooldown Flag ---
                    cardItem.dataset.isAnimating = 'false';
                }, 150);
            } else {
                // --- NEW: Failsafe ---
                cardItem.dataset.isAnimating = 'false';
            }
        } else { // Desktop logic
            cardItem.classList.add('is-clicking');
            performImmediateStateUpdate();
            setTimeout(() => {
                updateCardStateInCollection(cardId);
                cardItem.classList.remove('is-clicking');
                // --- NEW: Remove Cooldown Flag ---
                cardItem.dataset.isAnimating = 'false';
            }, 60);
        }
    }

    function updateDeckDisplay() {
        const deckContainer = document.getElementById('current-deck');
        if (!deckContainer) {
            return;
        }

        const deckCountBadge = document.querySelector('.deck-counter');
        if (deckCountBadge) {
            const count = currentDeck.length;
            deckCountBadge.textContent = `${count}/20`;
            deckCountBadge.classList.toggle('full', count === 20);
        }

        deckContainer.innerHTML = ''; // Clear previous slots
        const rowDiv = document.createElement('div');
        rowDiv.className = 'row g-2';

        // Keep track of which selected cover card IDs have already had their number displayed
        // to handle multiple instances of the same card type in the deck.
        let numberedStarsPlaced = {}; // e.g., { "card_id_as_cover1": true, "card_id_as_cover2": true }

        for (let i = 0; i < 20; i++) {
            const cardInSlot = i < currentDeck.length ? currentDeck[i] : null; // Get the specific card object for this slot
            const colDiv = document.createElement('div');
            colDiv.className = 'col-3 mb-2 card-slot'; // Ensure this class matches your layout needs
            const cardContainer = document.createElement('div');
            cardContainer.className = 'position-relative card-slot-container';

            if (cardInSlot) { // Check if there's a card for this slot
                cardContainer.classList.add('filled');
                cardContainer.dataset.cardId = cardInSlot.id;

                const highResPath = getHighResUrl(cardInSlot.display_image_path);
                if (highResPath) {
                    cardContainer.dataset.highResSrc = highResPath;
                    // Debug logging removed for production
                } else {
                    // No high-res path available
                }

                const img = document.createElement('img');
                // Check if high-res version is cached and use it if available
                const highResSrc = getHighResUrl(cardInSlot.display_image_path);
                let imgSrc = cardInSlot.display_image_path;
                
                if (highResSrc && highResImageCache.has(highResSrc)) {
                    imgSrc = highResSrc;
                    img.dataset.loadedResolution = 'high';
                }
                
                // Use the display_image_path of the specific card instance with proxy
                const proxyUrl = getImageUrl(imgSrc);
                img.src = proxyUrl; 
                img.alt = cardInSlot.name; // Use the name of the specific card instance
                img.className = 'img-fluid rounded';
                img.dataset.cardImage = 'true'; // Keep if used elsewhere
                img.dataset.originalSrc = cardInSlot.display_image_path; // Store original for progressive loading
                cardContainer.appendChild(img);
                
                // Don't auto-load high-res for deck slots - they're already visible
                // img.onload = () => {
                //     startProgressiveHighResLoading(img, cardInSlot.display_image_path, cardContainer);
                // };

                const removeBtn = document.createElement('button');
                removeBtn.className = 'btn btn-sm btn-danger position-absolute top-0 end-0 m-1 rounded-circle btn-remove';
                removeBtn.innerHTML = '-';
                removeBtn.title = `Remove ${cardInSlot.name}`;
                // removeBtn.dataset.slotIndex = i; // Optional: if remove logic needs the slot index directly
                cardContainer.appendChild(removeBtn);

                const starBtn = document.createElement('button');
                starBtn.className = 'btn-favorite';
                starBtn.type = 'button';
                // The star button should also reference the unique ID of the card in this slot
                starBtn.dataset.cardId = cardInSlot.id; 
                starBtn.setAttribute('aria-label', 'Set as cover card');

                const starIcon = document.createElement('i');
                starIcon.className = 'bi bi-star'; 

                const numberSpan = document.createElement('span');
                numberSpan.className = 'cover-card-number';
                
                starBtn.appendChild(starIcon);
                starBtn.appendChild(numberSpan);
                cardContainer.appendChild(starBtn);

            } else {
                cardContainer.classList.add('empty');
                const emptySlotDiv = document.createElement('div');
                emptySlotDiv.className = 'empty-slot d-flex align-items-center justify-content-center h-100';
                emptySlotDiv.innerHTML = '<div class="empty-slot-text">EMPTY</div>';
                cardContainer.appendChild(emptySlotDiv);
            }
            colDiv.appendChild(cardContainer);
            rowDiv.appendChild(colDiv);
        }
        deckContainer.appendChild(rowDiv);

        // After rendering all slots, call setCoverCardStarVisuals to apply active states and numbers
        setCoverCardStarVisuals(); 
    }

    function clearDeck() {
        if (currentDeck.length > 0) {
            // Only show confirmation if there are cards in the deck
            if (confirm('Are you sure you want to clear your deck?')) {
                // Clear the deck cards
                currentDeck = [];

                document.getElementById('deck-name').value = '';

                // Clear the selected energy types too
                selectedDeckEnergies = [];

                coverCardIds = [];

                // Reset the energy icon visual states
                updateDeckEnergyIconsVisualState();

                deckSaved = false;

                document.querySelectorAll('.card-item').forEach(cardEl => {
                    const cardContainer = cardEl.querySelector('.position-relative');
                    if (cardContainer) {
                        // Make the card clickable again
                        cardContainer.classList.remove('max-copies');
                        cardContainer.classList.add('clickable-card');

                        // Remove any existing count badge
                        const badge = cardContainer.querySelector('.badge');
                        if (badge) badge.remove();

                        // Remove any existing remove button
                        const removeBtn = cardContainer.querySelector('.btn-remove-small');
                        if (removeBtn) removeBtn.remove();
                    }
                });

                // Update the energy counter if it exists
                updateEnergyCounter();

                // Update displays
                updateDeckDisplay();
                updateCardDisplay();
                
            }
        } else {
            // If there are no cards, just clear energies without confirmation
            selectedDeckEnergies = [];

            document.getElementById('deck-name').value = '';

            // Reset the energy icon visual states
            document.querySelectorAll('.energy-selection-bar .energy-icon-wrapper').forEach(icon => {
                icon.classList.remove('active');
            });

            // Update the energy counter if it exists
            updateEnergyCounter();
        }
    }

    function getStageRank(cardTypes) {
        if (Array.isArray(cardTypes)) {
            for (const stage in stageOrder) {
                if (cardTypes.includes(stage)) {
                    return stageOrder[stage];
                }
            }
        }
        return stageOrder['default']; // Return default if cardTypes is not an array or no known stage is found
    }

    

    async function saveDeck() {
        const authStatus = await checkUserAuthentication();

        const deckNameValue = document.getElementById('deck-name').value.trim(); // Get name early for validation

        // Define a helper function to check for Basic Pokémon
        const hasBasicPokemon = () => {
            const pokemonCards = currentDeck.filter(card => card.card_type && card.card_type.includes('Pokémon'));
            return pokemonCards.some(card => card.card_type.includes('Basic'));
        };

        // --- Handle Unauthenticated User ---
        if (!authStatus.isAuthenticated) {

            // Validate deck before saving to sessionStorage and prompting
            if (currentDeck.length === 0) {
                alert('Your deck is empty! Please add some cards before trying to save.');
                return;
            }
            if (selectedDeckEnergies.length === 0) {
                alert('Please select at least one energy type for your deck.');
                // Optionally, highlight the energy selection area
                return;
            }
            // NEW VALIDATION: Check for Basic Pokémon
            if (!hasBasicPokemon()) {
                alert('Your deck must contain at least one Basic Pokémon before saving.');
                return;
            }
            if (!deckNameValue && currentDeck.length > 0) { // Prompt for name if deck has cards but no name
                alert('Please enter a name for your deck before saving.');
                document.getElementById('deck-name').focus();
                return;
            }

            // Deck is valid enough to save temporarily, store it
            const pendingDeck = {
                name: deckNameValue,
                cards: currentDeck.map(card => ({ id: card.id })), // Store card IDs
                deck_types: selectedDeckEnergies,
                cover_card_ids: coverCardIds
            };
            try {
                sessionStorage.setItem(PENDING_DECK_KEY, JSON.stringify(pendingDeck));
                sessionStorage.setItem(ACTION_AFTER_AUTH_KEY, 'savePendingDeck');

                // Show the modal to prompt login/signup
                showLoginToSaveModal();

            } catch (e) {
                alert("Could not temporarily save your deck. Browser storage might be full or disabled.");
            }
            return; // Stop further execution of saveDeck
        }

        // --- User IS Authenticated: Proceed with Server Save ---

        // Re-check validations for authenticated save
        if (currentDeck.length === 0) {
            alert('Your deck is empty! Please add some cards before saving.');
            return;
        }
        if (selectedDeckEnergies.length === 0) {
            alert('Please select at least one energy type for your deck before saving.');
            return;
        }
        // NEW VALIDATION: Check for Basic Pokémon
        if (!hasBasicPokemon()) {
            alert('Your deck must contain at least one Basic Pokémon before saving.');
            return;
        }
        if (!deckNameValue) {
            alert('Please enter a name for your deck.');
            document.getElementById('deck-name').focus();
            return;
        }

        // Auto-assign cover card logic (same as before)
        let autoAssignedCoverCardId = coverCardIds;
        if (autoAssignedCoverCardId === null && currentDeck.length > 0) {
            let candidateCard = null;
            const pokemonCards = currentDeck.filter(card => card.card_type && card.card_type.includes('Pokémon'));
            if (pokemonCards.length > 0) {
                const highestRarityRank = Math.min(...pokemonCards.map(card => getRank(card.rarity, rarityOrder)));
                const highestRarityPokemon = pokemonCards.filter(card => getRank(card.rarity, rarityOrder) === highestRarityRank);
                const highestStageRank = Math.min(...highestRarityPokemon.map(card => getStageRank(card.card_type)));
                const bestPokemonCandidates = highestRarityPokemon.filter(card => getStageRank(card.card_type) === highestStageRank);
                if (bestPokemonCandidates.length > 0) candidateCard = bestPokemonCandidates[0];
            }
            if (candidateCard === null) {
                if (currentDeck.length > 0) {
                    const highestRarityRankAll = Math.min(...currentDeck.map(card => getRank(card.rarity, rarityOrder)));
                    const highestRarityAllCards = currentDeck.filter(card => getRank(card.rarity, rarityOrder) === highestRarityRankAll);
                    if (highestRarityAllCards.length > 0) candidateCard = highestRarityAllCards[0];
                }
            }
            if (candidateCard !== null) autoAssignedCoverCardId = candidateCard.id;
            else if (currentDeck.length > 0) autoAssignedCoverCardId = currentDeck[0].id;
        }

        const deckData = {
            name: deckNameValue, // Use validated name
            cards: currentDeck.map(card => ({ id: card.id })),
            deck_types: selectedDeckEnergies,
            cover_card_ids: autoAssignedCoverCardId
        };


        const isUpdating = !!loadedDeckId;
        const url = isUpdating ? `/api/decks/${loadedDeckId}` : '/api/decks'; // Ensure API endpoint is correct
        const method = isUpdating ? 'PUT' : 'POST';

        // Fetch call (same as before)
        fetch(url, {
            method: method,
            headers: { 'Content-Type': 'application/json', /* Add CSRF token header if needed */ },
            body: JSON.stringify(deckData)
        })
        .then(response => {
            if (!response.ok) { // Improved error handling
                return response.json().then(err => { throw (err || {error: `HTTP error! Status: ${response.status}`}); });
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                deckSaved = true;
                if (data.filename && !isUpdating) {
                    loadedDeckId = data.filename;
                }
                if (data.cover_card_ids) {
                    coverCardIds = data.cover_card_ids;
                }
                
                // Clear auto-saved data on successful save
                clearAutoSavedData();
                
                window.location.href = '/collection'; // Redirect after save
            } else {
                // Use server's error message if available
                alert(`Error saving deck: ${data.error || 'Unknown server error'}`);
            }
        })
        .catch(error => {
            // Display the error message from the server if present, otherwise generic
            alert(`Error saving deck: ${error.error || 'An unexpected network or server error occurred.'}`);
        });
    }


    function getRank(value, orderMap) {
        return orderMap[value] ?? orderMap['default']; // Use default if value not in map
    }

    function getSortComparisonFunction(sortType, sortDirection) {
        const directionMultiplier = sortDirection === 'asc' ? 1 : -1;

        switch (sortType) {
            case 'name':
                return (a, b) => a.name.localeCompare(b.name) * directionMultiplier;

            case 'rarity':
                return (a, b) => {
                    const rankA = getRank(a.rarity, rarityOrder);
                    const rankB = getRank(b.rarity, rarityOrder);
                    if (rankA !== rankB) {
                        return (rankA - rankB) * directionMultiplier;
                    }

                    // Secondary sort: Set (newness), respecting primary sort direction.
                    const promoSetName = "Promo-A"; 
                    const isAPromo = (a.set_name === promoSetName);
                    const isBPromo = (b.set_name === promoSetName);
                    
                    if (isAPromo && !isBPromo) {
                        // A is promo, B is not - when desc, promo comes first; when asc, promo comes last
                        return directionMultiplier === -1 ? -1 : 1;
                    }
                    if (!isAPromo && isBPromo) {
                        // B is promo, A is not - when desc, promo comes first; when asc, promo comes last
                        return directionMultiplier === -1 ? 1 : -1;
                    }
                    
                    if (!(isAPromo && isBPromo)) { // If not both promos, compare by set order
                        const indexA = orderedSetNamesForSort.indexOf(a.set_name);
                        const indexB = orderedSetNamesForSort.indexOf(b.set_name);
                        const effectiveIndexA = indexA === -1 ? Infinity : indexA;
                        const effectiveIndexB = indexB === -1 ? Infinity : indexB;

                        if (effectiveIndexA !== effectiveIndexB) {
                            return (effectiveIndexA - effectiveIndexB) * directionMultiplier;
                        }
                    }

                    // Tertiary sort: by global integer card ID (ascending) for stability.
                    const idA = a.id || 0;
                    const idB = b.id || 0;
                    return idA - idB;
                };

            case 'set':
                return (a, b) => {
                    const promoSetName = "Promo-A"; // Or your exact promo set name

                    // Handle Promo-A position based on direction
                    const isAPromo = (a.set_name === promoSetName);
                    const isBPromo = (b.set_name === promoSetName);
                    
                    if (isAPromo && !isBPromo) {
                        // A is promo, B is not - when desc, promo comes first; when asc, promo comes last
                        return directionMultiplier === -1 ? -1 : 1;
                    }
                    if (!isAPromo && isBPromo) {
                        // B is promo, A is not - when desc, promo comes first; when asc, promo comes last
                        return directionMultiplier === -1 ? 1 : -1;
                    }
                    if (isAPromo && isBPromo) { // Both are promo, sort by card number
                        const numA = parseInt(a.card_number, 10) || 0;
                        const numB = parseInt(b.card_number, 10) || 0;
                        return (numA - numB) * directionMultiplier;
                    }

                    const indexA = orderedSetNamesForSort.indexOf(a.set_name);
                    const indexB = orderedSetNamesForSort.indexOf(b.set_name);

                    const effectiveIndexA = indexA === -1 ? Infinity : indexA;
                    const effectiveIndexB = indexB === -1 ? Infinity : indexB;

                    if (effectiveIndexA !== effectiveIndexB) {
                        return (effectiveIndexA - effectiveIndexB) * directionMultiplier;
                    }

                    const idA = a.id || 0;
                    const idB = b.id || 0;
                    return idA - idB;
                };

            case 'type':
                return (a, b) => {
                    const typeA_val = a.card_type.includes('Trainer') ? 'Trainer' : (a.energy_type || 'default');
                    const typeB_val = b.card_type.includes('Trainer') ? 'Trainer' : (b.energy_type || 'default');
                    const rankA_type = getRank(typeA_val, typeOrder);
                    const rankB_type = getRank(typeB_val, typeOrder);

                    if (rankA_type !== rankB_type) {
                        return (rankA_type - rankB_type) * directionMultiplier;
                    }

                    // --- Types are the same, proceed to tie-breaking ---
                    // Tie-breaker 1: Set (newness, using orderedSetNamesForSort)
                    const promoSetName = "Promo-A"; 
                    const isAPromo = (a.set_name === promoSetName);
                    const isBPromo = (b.set_name === promoSetName);

                    if (isAPromo && !isBPromo) {
                        // A is promo, B is not - when desc, promo comes first; when asc, promo comes last
                        return directionMultiplier === -1 ? -1 : 1;
                    }
                    if (!isAPromo && isBPromo) {
                        // B is promo, A is not - when desc, promo comes first; when asc, promo comes last
                        return directionMultiplier === -1 ? 1 : -1;
                    }
                    
                    if (!(isAPromo && isBPromo)) { // If not both promos, compare by set order
                        const indexA = orderedSetNamesForSort.indexOf(a.set_name);
                        const indexB = orderedSetNamesForSort.indexOf(b.set_name);
                        const effectiveIndexA = indexA === -1 ? Infinity : indexA;
                        const effectiveIndexB = indexB === -1 ? Infinity : indexB;

                        if (effectiveIndexA !== effectiveIndexB) {
                            return (effectiveIndexA - effectiveIndexB) * directionMultiplier;
                        }
                    }
                    // If sets are also the same (or both are promos and thus set order is same for this check),
                    // or if one/both sets were not in orderedSetNamesForSort (Infinity vs Infinity)
                    // then tie-break by global integer card ID (ascending).
                    const idA = a.id || 0;
                    const idB = b.id || 0;
                    if (idA !== idB) {
                        // Ascending ID sort is usually desired as a final numeric tie-breaker
                        return idA - idB; 
                    }

                    // Ultimate fallback: name (if IDs were somehow identical, though they should be unique)
                    return a.name.localeCompare(b.name) * directionMultiplier;
                };default: // Default to name ascending
                return (a, b) => a.name.localeCompare(b.name);
        }
    }

    function sortFilteredCards() {
        if (filteredCards && filteredCards.length > 0) {
            const compareFn = getSortComparisonFunction(currentSortType, currentSortDirection);
            filteredCards.sort(compareFn);
        }
    }

    function updateSortDropdownUI() {
        const sortButton = document.getElementById('sortDropdownButton'); // Gets the main sort button
        const sortDropdownMenu = document.getElementById('sort-options-dropdown'); // Gets the dropdown menu UL
        if (!sortButton || !sortDropdownMenu) return;

        let buttonBaseText = "Sort By"; // Default text if no active sort is found (shouldn't happen if currentSortType is valid)
        let foundActive = false; // Flag to confirm we found the active sort type in the menu


        // Loop through each link (sort option) in the dropdown menu
        sortDropdownMenu.querySelectorAll('a.dropdown-item').forEach(a => {
            const type = a.dataset.sortType; // Get the sort type from the data attribute

            // Find or create the span element for the arrow within the menu item
            let arrowSpan = a.querySelector('.sort-arrow');
            if (!arrowSpan) {
                arrowSpan = document.createElement('span');
                arrowSpan.className = 'sort-arrow';
                a.appendChild(document.createTextNode(' ')); // Add a space before the arrow span
                a.appendChild(arrowSpan);
            }

            // --- Reset the visual state of this menu item ---
            a.classList.remove('active'); // Remove active highlighting
            arrowSpan.innerHTML = ''; // Clear any existing arrow icon

            // --- Check if this menu item corresponds to the currently active sort ---
            if (type === currentSortType) {
                foundActive = true; // We found the active sort type

                // --- Update the visual state of the active menu item ---
                a.classList.add('active'); // Add active highlighting
                // Set the correct arrow icon for the dropdown menu item (flipped logic: down for asc, up for desc)
                arrowSpan.innerHTML = currentSortDirection === 'asc' ? '<i class="bi bi-arrow-down"></i>' : '<i class="bi bi-arrow-up"></i>';

                // --- Extract the base text for the main sort button from this active menu item ---
                // Try to get the text content of the first child node (the text before the arrow span)
                buttonBaseText = a.firstChild?.textContent?.trim() || '';
                // Fallback in case firstChild isn't a text node or is empty, by replacing arrow text
                if (buttonBaseText === '') {
                    buttonBaseText = a.textContent.replace(arrowSpan.textContent, '').trim();
                }

            }
        });

        // --- Set the HTML content of the main sort button ---
        // Include the extracted base text and the correct arrow icon (using the flipped logic)
        const buttonArrowHtml = currentSortDirection === 'asc' ? '<i class="bi bi-arrow-down"></i>' : '<i class="bi bi-arrow-up"></i>';
        sortButton.innerHTML = `${buttonBaseText} ${buttonArrowHtml}`;

        // Optional: If foundActive is false, it means currentSortType isn't a valid option in the menu.
        // For this application, currentSortType is initialized to 'set' which is in the menu,
        // and sort clicks only set it to other valid menu options, so this case should ideally not be reached.
        if (!foundActive) {
        }
    }

    async function checkUserAuthentication() {
        // Ensure these window variables are being set by your Flask template
        if (typeof window.IS_USER_AUTHENTICATED !== 'undefined') {
            // Directly return the values (no need for Promise if immediately available)
            return {
                isAuthenticated: window.IS_USER_AUTHENTICATED === true,
                user: window.IS_USER_AUTHENTICATED ? window.CURRENT_USER_DATA : null
            };
        } else {
            // Fallback or error if the global variables aren't set
            return { isAuthenticated: false, user: null }; // Assume not authenticated if check fails
        }
    }

    function showLoginToSaveModal() {
        const modal = document.getElementById('loginToSaveModal');
        const closeBtn = modal.querySelector('.auth-modal-close-btn');
        const googleSignInBtn = document.getElementById('loginToSaveModal_googleBtn');

        if (!modal || !closeBtn || !googleSignInBtn) {
            // Fallback to a simple confirm if modal is somehow broken
            if (confirm("You need to sign in with Google to save your deck. Your deck progress has been remembered. Proceed to Google Sign-In?")) {
                deckSaved = true; // Temporarily mark as saved to bypass unload warning
                const nextUrl = window.location.pathname + window.location.search;
                // Assumes google_bp is registered with url_prefix="/login" in Flask
                window.location.href = `/login/google?next=${encodeURIComponent(nextUrl)}`;
            }
            return;
        }

        // Function to close the modal and clean up window click listener
        const closeModalAndCleanup = () => {
            modal.style.display = 'none';
            window.removeEventListener('click', windowClickHandlerForModal); // Remove the specific listener
        };

        // Handler for clicking outside the modal content to close it
        const windowClickHandlerForModal = (event) => {
            if (event.target == modal) {
                closeModalAndCleanup();
            }
        };

        // Attach event listeners (these are set each time modal is shown)
        closeBtn.onclick = closeModalAndCleanup;

        googleSignInBtn.onclick = function() {
        deckSaved = true; // To bypass the beforeunload warning

        const currentDeckBuilderUrl = window.location.pathname + window.location.search;

        // Step 1: Asynchronously store the currentDeckBuilderUrl in the session via our new endpoint
        fetch('/auth/store-intended-redirect', { // Path to your new Flask route
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                // If you use CSRF protection for POST requests, you'll need to include the CSRF token here.
                // For example: 'X-CSRFToken': getCsrfToken() // (you'd need a getCsrfToken function)
            },
            body: JSON.stringify({ next_url: currentDeckBuilderUrl })
        })
        .then(response => {
            if (!response.ok) {
                // If response is not OK, throw an error to be caught by .catch()
                return response.json().then(err => { throw err; });
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                // Step 2: Now redirect to Google login.
                // The `?next=` parameter on this Google login URL is now less critical for *your* app's redirect logic,
                // as `custom_login_next_url` is set. However, it's good practice to still include it,
                // as Flask-Dance might use it for its own internal state or if its behavior changes.
                const googleLoginUrl = `/login/google?next=${encodeURIComponent(currentDeckBuilderUrl)}`;
                window.location.href = googleLoginUrl;
            } else {
                alert("Could not prepare for login. You may be redirected to the homepage after signing in.");
                // Fallback: proceed to Google login anyway, hoping for the best or default redirect.
                const googleLoginUrl = `/login/google?next=${encodeURIComponent(currentDeckBuilderUrl)}`;
                window.location.href = googleLoginUrl;
            }
        })
        .catch(error => {
            alert("An error occurred while preparing for login. You might be redirected to the homepage after signing in.");
            // Fallback redirect in case of network error etc.
            const googleLoginUrl = `/login/google?next=${encodeURIComponent(currentDeckBuilderUrl)}`;
            window.location.href = googleLoginUrl;
            });
        };

        // Add window click listener specifically for closing this modal when it's open
        // Remove any old one first to prevent multiple listeners if modal is shown repeatedly
        window.removeEventListener('click', windowClickHandlerForModal);
        window.addEventListener('click', windowClickHandlerForModal);

        modal.style.display = 'block'; // Show the modal
    }

    function isDeckPristineOrEmpty() {
        const deckName = document.getElementById('deck-name').value.trim();
        const hasNoCards = currentDeck.length === 0;
        const hasNoName = deckName === '';
        const hasNoEnergies = selectedDeckEnergies.length === 0;

        // A deck is considered pristine/empty if it has no cards, no name, and no energies selected.
        // This typically represents the initial state of a new deck or a completely cleared deck.
        if (hasNoCards && hasNoName && hasNoEnergies) {
            return true;
        }
        return false;
    }

    // In your Deck Builder's JavaScript
    function setCoverCardStarVisuals() {
        const deckContainer = document.getElementById('current-deck');
        if (!deckContainer) {
            return;
        }

        const starButtons = deckContainer.querySelectorAll('.btn-favorite'); // These are the star buttons in your rendered deck slots
        
        // Iterate through each star button in the deck display
        starButtons.forEach(starBtn => {
            const cardIdInSlot = starBtn.dataset.cardId; // The master ID of the card in this slot
            const numberSpan = starBtn.querySelector('.cover-card-number');
            const icon = starBtn.querySelector('i');

            if (!cardIdInSlot) { // Should ideally not happen if slots are rendered correctly
                starBtn.classList.remove('active');
                if (icon) icon.className = 'bi bi-star';
                if (numberSpan) numberSpan.textContent = '';
                starBtn.setAttribute('aria-label', 'Set as cover card');
                return; // Move to the next star button
            }

            // Check if this card's ID is in our list of selected cover card IDs
            // Ensure consistent type for indexOf, assuming coverCardIds stores strings
            const indexOfThisCardInSelection = coverCardIds.indexOf(cardIdInSlot.toString()); 

            if (indexOfThisCardInSelection > -1) {
                // This card IS one of the selected cover cards.
                // It gets an active star and its corresponding order number.
                starBtn.classList.add('active');
                if (icon) {
                    icon.classList.remove('bi-star');
                    icon.classList.add('bi-star-fill');
                }
                
                const orderNumber = indexOfThisCardInSelection + 1; // This will be 1, 2, or 3
                if (numberSpan) {
                    numberSpan.textContent = orderNumber.toString();
                }
                starBtn.setAttribute('aria-label', `Cover Card ${orderNumber} - Unset`);
            } else {
                // This card is NOT a selected cover card. Reset it to default.
                starBtn.classList.remove('active');
                if (icon) {
                    icon.classList.remove('bi-star-fill');
                    icon.classList.add('bi-star');
                }
                if (numberSpan) {
                    numberSpan.textContent = '';
                }
                starBtn.setAttribute('aria-label', 'Set as cover card');
            }
        });

    }
    
</script>
{% endblock %}